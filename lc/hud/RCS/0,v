head	1.55;
access;
symbols;
locks
	alex:1.55; strict;
comment	@# @;


1.55
date	2006.07.13.18.42.34;	author alex;	state Exp;
branches;
next	1.54;

1.54
date	2006.07.13.17.28.49;	author alex;	state Exp;
branches;
next	1.53;

1.53
date	2006.07.13.17.27.13;	author alex;	state Exp;
branches;
next	1.52;

1.52
date	2006.07.13.16.34.43;	author alex;	state Exp;
branches;
next	1.51;

1.51
date	2006.07.13.13.14.30;	author alex;	state Exp;
branches;
next	1.50;

1.50
date	2006.07.13.13.11.37;	author alex;	state Exp;
branches;
next	1.49;

1.49
date	2006.07.13.13.04.58;	author alex;	state Exp;
branches;
next	1.48;

1.48
date	2006.07.13.13.03.36;	author alex;	state Exp;
branches;
next	1.47;

1.47
date	2006.07.13.13.02.58;	author alex;	state Exp;
branches;
next	1.46;

1.46
date	2006.07.13.13.02.27;	author alex;	state Exp;
branches;
next	1.45;

1.45
date	2006.07.13.13.00.44;	author alex;	state Exp;
branches;
next	1.44;

1.44
date	2006.07.13.13.00.13;	author alex;	state Exp;
branches;
next	1.43;

1.43
date	2006.07.13.12.59.15;	author alex;	state Exp;
branches;
next	1.42;

1.42
date	2006.07.13.12.59.10;	author alex;	state Exp;
branches;
next	1.41;

1.41
date	2006.07.13.12.58.04;	author alex;	state Exp;
branches;
next	1.40;

1.40
date	2006.07.13.12.57.54;	author alex;	state Exp;
branches;
next	1.39;

1.39
date	2006.07.13.12.52.17;	author alex;	state Exp;
branches;
next	1.38;

1.38
date	2006.07.13.12.52.10;	author alex;	state Exp;
branches;
next	1.37;

1.37
date	2006.07.13.12.51.46;	author alex;	state Exp;
branches;
next	1.36;

1.36
date	2006.07.13.12.47.22;	author alex;	state Exp;
branches;
next	1.35;

1.35
date	2006.07.13.12.46.41;	author alex;	state Exp;
branches;
next	1.34;

1.34
date	2006.07.13.12.46.29;	author alex;	state Exp;
branches;
next	1.33;

1.33
date	2006.07.13.12.45.48;	author alex;	state Exp;
branches;
next	1.32;

1.32
date	2006.07.13.12.44.10;	author alex;	state Exp;
branches;
next	1.31;

1.31
date	2006.07.13.12.43.23;	author alex;	state Exp;
branches;
next	1.30;

1.30
date	2006.07.13.12.42.57;	author alex;	state Exp;
branches;
next	1.29;

1.29
date	2006.07.13.12.32.27;	author alex;	state Exp;
branches;
next	1.28;

1.28
date	2006.07.13.12.31.44;	author alex;	state Exp;
branches;
next	1.27;

1.27
date	2006.07.13.12.30.07;	author alex;	state Exp;
branches;
next	1.26;

1.26
date	2006.07.13.12.29.41;	author alex;	state Exp;
branches;
next	1.25;

1.25
date	2006.07.13.12.28.54;	author alex;	state Exp;
branches;
next	1.24;

1.24
date	2006.07.13.12.21.55;	author alex;	state Exp;
branches;
next	1.23;

1.23
date	2006.07.13.12.21.35;	author alex;	state Exp;
branches;
next	1.22;

1.22
date	2006.07.13.12.20.45;	author alex;	state Exp;
branches;
next	1.21;

1.21
date	2006.07.13.12.20.26;	author alex;	state Exp;
branches;
next	1.20;

1.20
date	2006.07.13.12.19.40;	author alex;	state Exp;
branches;
next	1.19;

1.19
date	2006.07.13.12.19.18;	author alex;	state Exp;
branches;
next	1.18;

1.18
date	2006.07.13.12.14.54;	author alex;	state Exp;
branches;
next	1.17;

1.17
date	2006.07.13.12.11.25;	author alex;	state Exp;
branches;
next	1.16;

1.16
date	2006.07.13.12.10.53;	author alex;	state Exp;
branches;
next	1.15;

1.15
date	2006.07.13.12.10.11;	author alex;	state Exp;
branches;
next	1.14;

1.14
date	2006.07.13.12.09.55;	author alex;	state Exp;
branches;
next	1.13;

1.13
date	2006.07.13.12.04.50;	author alex;	state Exp;
branches;
next	1.12;

1.12
date	2006.07.13.12.04.07;	author alex;	state Exp;
branches;
next	1.11;

1.11
date	2006.07.13.12.04.01;	author alex;	state Exp;
branches;
next	1.10;

1.10
date	2006.07.13.12.03.59;	author alex;	state Exp;
branches;
next	1.9;

1.9
date	2006.07.13.12.03.39;	author alex;	state Exp;
branches;
next	1.8;

1.8
date	2006.07.13.12.03.37;	author alex;	state Exp;
branches;
next	1.7;

1.7
date	2006.07.13.12.03.13;	author alex;	state Exp;
branches;
next	1.6;

1.6
date	2006.07.13.12.02.05;	author alex;	state Exp;
branches;
next	1.5;

1.5
date	2006.07.13.12.00.51;	author alex;	state Exp;
branches;
next	1.4;

1.4
date	2006.07.13.12.00.22;	author alex;	state Exp;
branches;
next	1.3;

1.3
date	2006.07.13.11.59.03;	author alex;	state Exp;
branches;
next	1.2;

1.2
date	2006.07.13.11.58.19;	author alex;	state Exp;
branches;
next	1.1;

1.1
date	2006.07.13.11.51.17;	author alex;	state Exp;
branches;
next	;


desc
@Thu Jul 13 12:51:17 2006
@


1.55
log
@Thu Jul 13 19:42:34 2006
@
text
@# 5 <<+ silence
# oh

use YAML;
my $chunksize = 4;

my $sample = "drum/0";

my $scripts = 
    {volume => "18 <<+ 0 <<< 4 <<+ silence",
     speed  => "1 - 3 <<- silence",
    };

my $ops = {'<<+' => sub {mask(shift, 100, @@_)},
           '<<-' => sub {mask(shift, 0, @@_)  },
           '<<<' => sub {rotate(shift, @@_)   },
           '-'   => sub {minus(shift, @@_)    },
           '+'   => sub {plus(shift, @@_)     },
          };

sub bang {
    my $self = shift;
    my $seq = $self->{seq} || '';

    my $sound = {};
    foreach my $name (keys %$scripts) {
        $sound->{$name} = $self->nextbit($name);
    }

    warn(Dump $sound);

    $self->t({sample =>  $sample,
              speed  => $sound->{speed},
              volume => 1 #$sound->{volume}
             }
            ) if $sound->{volume};

    $self->modified;
}

sub nextbit {
    my ($self, $name) = @@_;
    my $seq = $self->{seqs}->{$name};
    if ((not $seq) or (not @@$seq)) {
        my $script = $scripts->{$name};
        $seq = $self->parse($script, $chunksize);
    }
    my $result = shift(@@$seq);
    $self->{seqs}->{$name} = $seq;
    return($result);
}

sub parse {
    my ($self, $script, $chunksize) = @@_;

    my $result;

    $script =~ s/^\s+//;
    $script =~ s/\s+$//;
    my @@tokens = split(/\s+/, $script);
    my $generator = pop(@@tokens);
    my $param;
    if ($generator =~ s/\((.*)\)//) {
        $param = $1;
    }
    my $func = "gen_$generator";
    if ($self->can($func)) {
       $result = $self->$func($chunksize, $param);
    }

    while (@@tokens) {
       my $op = pop @@tokens;
       my $value = pop @@tokens;

       my $func = $ops->{$op};

       if (not $func) {
           warn("parse error: no op '$op'\n");
       }
       else {
           $func->($self, $value, $result);
       }
    }

    return($result);
}


sub gen_silence {
    my ($self, $chunksize) = @@_;
    return [map {0} (0 .. ($chunksize - 1))];
}

sub gen_sine {
    my ($self, $chunksize, $param) = @@_;
    my $result = [];
    $param ||= 1;
    foreach my $i (0 .. $chunksize - 1) {
      push(@@$result, sin(($i + $self->{bangs}) / $param));
    }

    return($result);
}

sub mask {
    my ($self, $maskvalue, $mod, $stream) = @@_;
    my $point = $self->{bangs};
    warn("point: $point $maskvalue $mod " . scalar(@@$stream) . "\n");
    foreach my $i (0 .. @@$stream - 1) {
        if (($point + $i) % $mod == 0) {
            $stream->[$i] = $maskvalue;
        }
    }
}

sub rotate {
    my ($self, $rotvalue, $stream) = @@_;
    foreach my $foo (0 .. $rotvalue - 1) {
       push(@@$stream, shift(@@$stream));
    }
}
sub plus {
    my ($self, $plusvalue, $stream) = @@_;
    foreach my $i (0 .. @@$stream - 1) {
        $stream->[$i] += $plusvalue
           if $stream->[$i];
    }
}

sub minus {
    my ($self, $minusvalue, $stream) = @@_;
    foreach my $i (0 .. @@$stream - 1) {
        $stream->[$i] -= $minusvalue
            if $stream->[$i];
    }
}
@


1.54
log
@Thu Jul 13 18:28:49 2006
@
text
@d11 1
a11 1
#     speed  => "3 <<- sine(0.1)",
d16 3
a18 1
           '<<<' => sub {rotate(shift, @@_)   }
d121 16
a136 1
}@


1.53
log
@Thu Jul 13 18:27:13 2006
@
text
@d10 1
a10 1
    {volume => "0 <<< 4 <<+ silence",
@


1.52
log
@Thu Jul 13 17:34:43 2006
@
text
@d10 1
a10 1
    {volume => "2 <<< 4 <<+ silence",
d119 1
a119 2
}

@


1.51
log
@Thu Jul 13 14:14:30 2006
@
text
@d10 2
a11 2
    {volume => "4 <<+ silence",
     speed  => "sine(0.3)",
d114 7
@


1.50
log
@Thu Jul 13 14:11:37 2006
@
text
@d10 2
a11 2
    {volume => "1 <<+ silence",
     speed  => "sine(0.1)",
d95 1
a95 1
    my $param ||= 1;
@


1.49
log
@Thu Jul 13 14:04:58 2006
@
text
@d11 1
a11 1
     speed  => "sine",
d60 4
d66 1
a66 1
       $result = $self->$func($chunksize);
d72 1
d93 1
a93 2
    my ($self, $chunksize) = @@_;

d95 1
a95 1

d97 1
a97 1
      push(@@$result, sin($i + $self->{bangs}));
@


1.48
log
@Thu Jul 13 14:03:36 2006
@
text
@d5 1
a5 1
my $chunksize = 16;
d7 1
a7 1
my $sample = "sid/0";
d10 1
a10 1
    {volume => "8 <<+ silence",
@


1.47
log
@Thu Jul 13 14:02:58 2006
@
text
@d31 1
@


1.46
log
@Thu Jul 13 14:02:27 2006
@
text
@d7 1
a7 1
my $sample = "Âsid/0";
d10 1
a10 1
    {volume => "5 <<+ silence",
@


1.45
log
@Thu Jul 13 14:00:44 2006
@
text
@d30 4
@


1.44
log
@Thu Jul 13 14:00:13 2006
@
text
@d7 2
d30 1
@


1.43
log
@Thu Jul 13 13:59:15 2006
@
text
@d9 1
a9 1
     speed  => "3 <<+ silence",
d79 11
a89 11
#sub gen_sine {
#    my ($self, $chunksize) = @@_;
#
#    my $result = [];
#
#    foreach my $i (0 .. $chunksize - 1) {
#      push(@@$result, sin($i + $self->{bangs}));
#    }
#
#    return($result);
#}
@


1.42
log
@Thu Jul 13 13:59:10 2006
@
text
@a101 1
sub @


1.41
log
@Thu Jul 13 13:58:04 2006
@
text
@d79 11
a89 11
sub gen_sine {
    my ($self, $chunksize) = @@_;

    my $result;

    foreach my $i (0 .. $chunksize - 1) {
      return(sin($i + $self->{bangs}));
    }

    return($result);
}
@


1.40
log
@Thu Jul 13 13:57:54 2006
@
text
@d9 1
a9 1
     speed  => "3 <<+ sine",
@


1.39
log
@Thu Jul 13 13:52:17 2006
@
text
@d9 1
a9 1
     speed  => "3 <<+ silence",
d26 1
a26 1
    warn("hm: " . Dump $sound);
d34 1
a34 1
    if ((not $seq) and (not @@$seq)) {
d79 12
d100 3
a102 1
}@


1.38
log
@Thu Jul 13 13:52:10 2006
@
text
@a33 1
    warn("next bit for $name\n");
@


1.37
log
@Thu Jul 13 13:51:46 2006
@
text
@d35 1
a35 1
    if ((not $seq or (not @@$seq)) {
a36 1
        warn("next from $script\n");
a38 1
    warn("hmm\n");
a39 1
    warn("ha\n");
@


1.36
log
@Thu Jul 13 13:47:22 2006
@
text
@d25 2
a26 1
    warn(Dump $sound);
d34 2
a35 2

    if (not @@$seq) {
d40 1
d42 1
@


1.35
log
@Thu Jul 13 13:46:41 2006
@
text
@d8 2
a9 1
    {volume => "5 <<+ silence"
@


1.34
log
@Thu Jul 13 13:46:29 2006
@
text
@d61 1
a61 1
       warn("op: $op\n");
a68 1
       warn(Dump $result);
@


1.33
log
@Thu Jul 13 13:45:48 2006
@
text
@d32 2
a33 1
    if (not $seq) {
@


1.32
log
@Thu Jul 13 13:44:10 2006
@
text
@d34 1
d37 1
a37 1
    my $result = shift($seq);
d70 1
a70 1
    return('oh');
@


1.31
log
@Thu Jul 13 13:43:23 2006
@
text
@d21 1
a21 1
    foreach my $name (keys %Â$scripts) {
d31 1
a31 1
    my $seq = $self->{seqs}->{name};
d33 1
a33 1
        my $script = $scripts->{name};
d37 1
a37 1
    $self->{seqs}->{name} = $seq;
@


1.30
log
@Thu Jul 13 13:42:57 2006
@
text
@d24 1
a25 1
    $self->line(1, $seq);
@


1.29
log
@Thu Jul 13 13:32:27 2006
@
text
@d7 4
d19 4
a22 3
    if (not $seq) {
        my $script = $self->line(0);
        $seq = $self->parse($script, $chunksize);
d24 1
d29 11
@


1.28
log
@Thu Jul 13 13:31:44 2006
@
text
@d50 1
a50 1
#       warn(Dump \@@result);
d67 1
a67 1
            $stream->[$point + $i] = $maskvalue;
@


1.27
log
@Thu Jul 13 13:30:07 2006
@
text
@d27 1
a27 1
    my @@result;
d35 1
a35 1
       @@result = $self->$func($chunksize);
d47 1
a47 1
           $func->($self, $value, \@@result);
d50 1
a50 1
       warn(Dump \@@result);
@


1.26
log
@Thu Jul 13 13:29:41 2006
@
text
@a35 1
       warn(Dump \@@result);
d50 1
@


1.25
log
@Thu Jul 13 13:28:54 2006
@
text
@d35 1
a35 1
       my @@result = $self->$func($chunksize);
d64 1
a64 1
    warn("point: $point $mod " . scalar(@@$stream) . "\n");
@


1.24
log
@Thu Jul 13 13:21:55 2006
@
text
@d7 3
a9 3
my $ops = {'<<+' => sub {mask(100, @@_)},
           '<<-' => sub {mask(0, @@_)  },
           '<<<' => sub {rotate(@@_)   }
d43 1
a43 1
       warn("op: $func\n");
d59 11
@


1.23
log
@Thu Jul 13 13:21:35 2006
@
text
@d7 3
a9 3
my $ops = {'<<+' => { sub {mask(100, @@_)} },
           '<<-' => { sub {mask(0, @@_)  } },
           '<<<' => { sub {rotate(@@_)   } }
@


1.22
log
@Thu Jul 13 13:20:45 2006
@
text
@d26 3
d35 2
a36 2
       my @@stream = $self->$func($chunksize);
       warn(Dump \@@stream);
d43 1
d48 1
a48 1
           $func->($self, $value, \@@stream);
@


1.21
log
@Thu Jul 13 13:20:26 2006
@
text
@d7 3
a9 3
my $ops = {'<<+' => {sub {mask(100, @@_)}},
           '<<-' => {sub {mask(0, @@_)}},
           '<<<' => {{sub rotate(@@_)}}
@


1.20
log
@Thu Jul 13 13:19:40 2006
@
text
@d7 3
a9 3
my $ops = {'<<+' => {sub mask(100, @@_)},
           '<<-' => {sub mask(0, @@_)},
           '<<<' => {sub rotate(@@_)}
@


1.19
log
@Thu Jul 13 13:19:18 2006
@
text
@d32 1
a32 1
       my @@stream = $self->func($chunksize);
@


1.18
log
@Thu Jul 13 13:14:54 2006
@
text
@d1 1
a1 1
# 5 <<+ sin
d4 1
d33 1
a33 1
       warn(\@@stream);
d35 13
@


1.17
log
@Thu Jul 13 13:11:25 2006
@
text
@d6 5
d40 2
a41 2
    return map {{}} (0 .. $chunksize - 1);
}
@


1.16
log
@Thu Jul 13 13:10:53 2006
@
text
@d2 1
a2 1
# 
d29 1
a29 1
    return('');
@


1.15
log
@Thu Jul 13 13:10:11 2006
@
text
@d27 1
d34 2
a35 1
    
@


1.14
log
@Thu Jul 13 13:09:55 2006
@
text
@d2 1
a2 1
# Sandbox=HASH(0x86f4e48)
d28 1
@


1.13
log
@Thu Jul 13 13:04:50 2006
@
text
@d19 15
a33 3
   my $self = shift;
   
}@


1.12
log
@Thu Jul 13 13:04:07 2006
@
text
@d2 1
a2 1
# 83
d20 1
a20 1
   $self->{bangs}
@


1.11
log
@Thu Jul 13 13:04:01 2006
@
text
@d2 1
a2 1
# 20
@


1.10
log
@Thu Jul 13 13:03:59 2006
@
text
@d2 1
a2 1
# 9
@


1.9
log
@Thu Jul 13 13:03:39 2006
@
text
@d2 1
a2 1
# 41
@


1.8
log
@Thu Jul 13 13:03:37 2006
@
text
@d2 1
a2 1
# 23
@


1.7
log
@Thu Jul 13 13:03:13 2006
@
text
@d2 1
a2 1
# 7
@


1.6
log
@Thu Jul 13 13:02:05 2006
@
text
@d2 1
a2 1
# 17
@


1.5
log
@Thu Jul 13 13:00:51 2006
@
text
@d2 1
a2 1
# 9
@


1.4
log
@Thu Jul 13 13:00:22 2006
@
text
@d2 1
a2 1
# 45
@


1.3
log
@Thu Jul 13 12:59:03 2006
@
text
@d2 1
a2 1
# 7
@


1.2
log
@Thu Jul 13 12:58:19 2006
@
text
@d2 1
a2 1
# 14
@


1.1
log
@Initial revision
@
text
@d1 5
d8 13
@
