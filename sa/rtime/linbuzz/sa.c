


/*
#    Sfront, a SAOL to C translator    
#    This file: Included file in sfront runtime
#    Copyright (C) 1999  Regents of the University of California
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License (Version 2) as
#    published by the Free Software Foundation.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#    Primary Author: John Lazzaro, lazzaro@cs.berkeley.edu
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <float.h>
#include <string.h>
#include <errno.h>
#include <time.h>
#include <signal.h>

/********************************/
/* readabiliy-improving defines */
/********************************/

#define NV(x)   nstate->v[x].f
#define NVI(x)  nstate->v[x].i
#define NVU(x)  nstate->v[x]
#define NT(x)   nstate->t[x]
#define NS(x)   nstate->x
#define NSP     nstate
#define NP(x)   nstate->v[x].f
#define NPI(x)  nstate->v[x].i
#define NG(x)   global[x].f
#define NGI(x)  global[x].i
#define NGU(x)  global[x]

#define TB(x)   bus[x]
#define STB(x)  sbus[x]
#define ROUND(x) ( ((x) > 0.0F) ? ((int) ((x) + 0.5F)) :  ((int) ((x) - 0.5F)))
#define POS(x)   (((x) > 0.0F) ? x : 0.0F)
#define RMULT ((float)(1.0F/(RAND_MAX + 1.0F)))

#define NOTUSEDYET 0
#define TOBEPLAYED 1
#define PAUSED     2
#define PLAYING    3
#define ALLDONE    4

#define NOTLAUNCHED 0
#define LAUNCHED 1

#define ASYS_DONE        0
#define ASYS_EXIT        1
#define ASYS_ERROR       2

#define IPASS 1
#define KPASS 2
#define APASS 3

#define IOERROR_RETRY 256 

/************************************/
/* externs for system functions     */
/************************************/

extern void epr(int, char *, char *, char *);
extern size_t rread(void * ptr, size_t len, size_t nmemb, FILE * stream);
extern size_t rwrite(void * ptr, size_t len, size_t nmemb, FILE * stream);

/************************************/
/*  union for a data stack element  */
/************************************/

typedef union {

float f;
long  i;

} dstack;


/************************************/
/* ntables: table entries for notes */
/************************************/

typedef struct tableinfo {

int    len;                /* length of table */
float  lenf;               /* length of table, as a float */

int    start;              /* loop start position */
int    end;                /* loop end position */
float  sr;                 /* table sampling rate  */
float  base;               /* table base frequency */

                           /* precomputed constants       */
int tend;                  /* len -1 if end==0            */
float m;                   /* start/len                   */
float n;                   /* end/len, if end=0 1-(1/len) */
float dmult;               /* sr*atime                    */
float lmult;               /* (sr*atime)/basefreq         */
float diff;                /* n - m                       */

float  *t;                 /* pointer to table entries    */
float stamp;               /* timestamp on table contents */
char llmem;                /* 1 if *t was malloced        */
} tableinfo; 

/********************/
/*  control lines   */
/********************/

typedef struct scontrol_lines {

float t;                  /* trigger time */
int label;                /* index into label array */
int siptr;                /* score instr line to control */
struct instr_line *iline; /* pointer to score line */
int imptr;                /* position of variable in v[] */
float imval;              /* value to import into v[] */

} scontrol_lines;

/********************/
/*   tempo lines    */
/********************/

typedef struct stempo_lines {

  float t;          /* trigger time */
  float newtempo;   /* new tempo */ 

} stempo_lines;

/********************/
/*   table lines    */
/********************/

typedef struct stable_lines {

  float t;          /* trigger time */
  int gindex;       /* global table to target */
  int size;         /* size of data */
  void (*tmake) (); /* function   */
  void * data;      /* data block */

} stable_lines;

/********************/
/* system variables */
/********************/

/* audio and control rates */

float globaltune = 440.0F;
float invglobaltune = 2.272727e-03F;
float scorebeats = 0.0F;              /* current score beat */
float absolutetime = 0.0F;            /* current absolute time */
int kbase = 1;                        /* kcycle of last tempo change */
float scorebase = 0.0F;               /* scorebeat of last tempo change */

/* counters & bounds acycles and kcycles */

int endkcycle;
int kcycleidx = 1;
int acycleidx = 0;
int pass = IPASS;
int beginflag;
sig_atomic_t graceful_exit;

struct instr_line * sysidx;

int busidx;        /* counter for buses                   */
int nextstate = 0; /* counter for active instrument state */
int oldstate;      /* detects loops in nextstate updates  */
int tstate;        /* flag for turnoff state machine      */
float cpuload;     /* current cpu-time value              */

int asys_argc;
char ** asys_argv;

int csys_argc;
char ** csys_argv;


int csys_sfront_argc = 15;

char * csys_sfront_argv[15] = {
"sfront",
"-gcc",
"-cpp",
"-Is",
"../../../lib",
"-latency",
"0.002",
"-aout",
"linux",
"-cin",
"linmidi",
"-orc",
"linbuzz.saol",
"-sco",
"linbuzz.sasl"};


#define APPNAME "sfront"
#define APPVERSION "0.85 10/13/02"
#define NSYS_NET 0
#define ARATE 44100.0F
#define ATIME 2.267574e-05F
#define KRATE 1050.0F
#define KTIME 9.523810e-04F
#define KMTIME 9.523810e-01F
#define KUTIME 952L
#define ACYCLE 42L
float tempo = 60.0F;
float scoremult = 9.523810e-04F;

#define ASYS_RENDER   0
#define ASYS_PLAYBACK 1
#define ASYS_TIMESYNC 2

#define ASYS_SHORT   0
#define ASYS_FLOAT   1

/* audio i/o */

#define ASYS_OCHAN 1L
#define ASYS_OTYPENAME  ASYS_SHORT
#define ASYS_OTYPE  short
long asys_osize = 0;
long obusidx = 0;

ASYS_OTYPE * asys_obuf = NULL;

#define ASYS_USERLATENCY  1
#define ASYS_LOWLATENCY   0
#define ASYS_HIGHLATENCY  1
#define ASYS_LATENCYTYPE  ASYS_LOWLATENCY
#define ASYS_LATENCY 0.002000F
#define ASYS_TIMEOPTION ASYS_PLAYBACK

#define MAXPFIELDS 2

struct instr_line { 

float starttime;  /* score start time of note */
float endtime;    /* score end time of note */
float startabs;   /* absolute start time of note */
float endabs;     /* absolute end time of note */
float abstime;    /* absolute time extension */
float time;       /* time of note start (absolute) */
float itime;      /* elapsed time (absolute) */
float sdur;       /* duration of note in score time*/

int kbirth;       /* kcycleidx for note launch */
int released;     /* flag for turnoff*/
int turnoff;      /* flag for turnoff */
int noteon;       /* NOTYETUSED,TOBEPLAYED,PAUSED,PLAYING,ALLDONE */
int notestate;    /* index into state array */
int launch;       /* only for dynamic instruments */
int numchan;      /* only for MIDI notes */
int preset;       /* only for MIDI notes */
int notenum;      /* only for MIDI notes */
int label;        /* SASL label index + 1, or 0 (no label) */

                  /* for static MIDI, all-sounds noteoff */

float p[MAXPFIELDS];          /* parameters */

struct ninstr_types * nstate; /* pointer into state array */

};


#define TRIGSIZE 2048

#define TRIGQUAD 512

#define TRIGSIZEF 2048.0F
float sintab[TRIGSIZE+TRIGQUAD] = { 
0.000000e+00F, 
3.067957e-03F, 6.135884e-03F, 9.203754e-03F, 1.227154e-02F, 1.533921e-02F, 1.840673e-02F, 2.147408e-02F, 2.454123e-02F, 
2.760814e-02F, 3.067480e-02F, 3.374117e-02F, 3.680722e-02F, 3.987293e-02F, 4.293825e-02F, 4.600318e-02F, 4.906767e-02F, 
5.213170e-02F, 5.519524e-02F, 5.825826e-02F, 6.132073e-02F, 6.438263e-02F, 6.744392e-02F, 7.050457e-02F, 7.356456e-02F, 
7.662386e-02F, 7.968243e-02F, 8.274026e-02F, 8.579731e-02F, 8.885355e-02F, 9.190895e-02F, 9.496349e-02F, 9.801714e-02F, 
1.010699e-01F, 1.041216e-01F, 1.071724e-01F, 1.102222e-01F, 1.132709e-01F, 1.163186e-01F, 1.193652e-01F, 1.224107e-01F, 
1.254550e-01F, 1.284981e-01F, 1.315400e-01F, 1.345807e-01F, 1.376201e-01F, 1.406582e-01F, 1.436950e-01F, 1.467305e-01F, 
1.497645e-01F, 1.527972e-01F, 1.558284e-01F, 1.588581e-01F, 1.618864e-01F, 1.649131e-01F, 1.679383e-01F, 1.709619e-01F, 
1.739839e-01F, 1.770042e-01F, 1.800229e-01F, 1.830399e-01F, 1.860551e-01F, 1.890687e-01F, 1.920804e-01F, 1.950903e-01F, 
1.980984e-01F, 2.011046e-01F, 2.041090e-01F, 2.071114e-01F, 2.101118e-01F, 2.131103e-01F, 2.161068e-01F, 2.191012e-01F, 
2.220936e-01F, 2.250839e-01F, 2.280721e-01F, 2.310581e-01F, 2.340419e-01F, 2.370236e-01F, 2.400030e-01F, 2.429802e-01F, 
2.459550e-01F, 2.489276e-01F, 2.518978e-01F, 2.548656e-01F, 2.578311e-01F, 2.607941e-01F, 2.637547e-01F, 2.667127e-01F, 
2.696683e-01F, 2.726213e-01F, 2.755718e-01F, 2.785197e-01F, 2.814649e-01F, 2.844075e-01F, 2.873474e-01F, 2.902847e-01F, 
2.932191e-01F, 2.961509e-01F, 2.990798e-01F, 3.020059e-01F, 3.049292e-01F, 3.078496e-01F, 3.107671e-01F, 3.136817e-01F, 
3.165934e-01F, 3.195020e-01F, 3.224077e-01F, 3.253103e-01F, 3.282098e-01F, 3.311063e-01F, 3.339996e-01F, 3.368898e-01F, 
3.397769e-01F, 3.426607e-01F, 3.455413e-01F, 3.484187e-01F, 3.512927e-01F, 3.541635e-01F, 3.570309e-01F, 3.598950e-01F, 
3.627557e-01F, 3.656130e-01F, 3.684668e-01F, 3.713172e-01F, 3.741640e-01F, 3.770074e-01F, 3.798472e-01F, 3.826834e-01F, 
3.855160e-01F, 3.883450e-01F, 3.911704e-01F, 3.939920e-01F, 3.968100e-01F, 3.996242e-01F, 4.024346e-01F, 4.052413e-01F, 
4.080441e-01F, 4.108432e-01F, 4.136383e-01F, 4.164295e-01F, 4.192169e-01F, 4.220003e-01F, 4.247797e-01F, 4.275551e-01F, 
4.303265e-01F, 4.330938e-01F, 4.358571e-01F, 4.386162e-01F, 4.413712e-01F, 4.441221e-01F, 4.468688e-01F, 4.496113e-01F, 
4.523496e-01F, 4.550836e-01F, 4.578133e-01F, 4.605387e-01F, 4.632598e-01F, 4.659765e-01F, 4.686888e-01F, 4.713967e-01F, 
4.741002e-01F, 4.767992e-01F, 4.794937e-01F, 4.821838e-01F, 4.848692e-01F, 4.875501e-01F, 4.902265e-01F, 4.928982e-01F, 
4.955652e-01F, 4.982276e-01F, 5.008854e-01F, 5.035384e-01F, 5.061866e-01F, 5.088301e-01F, 5.114688e-01F, 5.141027e-01F, 
5.167318e-01F, 5.193560e-01F, 5.219753e-01F, 5.245897e-01F, 5.271991e-01F, 5.298036e-01F, 5.324031e-01F, 5.349976e-01F, 
5.375871e-01F, 5.401714e-01F, 5.427508e-01F, 5.453250e-01F, 5.478940e-01F, 5.504579e-01F, 5.530167e-01F, 5.555702e-01F, 
5.581185e-01F, 5.606616e-01F, 5.631993e-01F, 5.657318e-01F, 5.682589e-01F, 5.707807e-01F, 5.732971e-01F, 5.758082e-01F, 
5.783138e-01F, 5.808139e-01F, 5.833086e-01F, 5.857978e-01F, 5.882815e-01F, 5.907597e-01F, 5.932323e-01F, 5.956993e-01F, 
5.981607e-01F, 6.006165e-01F, 6.030666e-01F, 6.055110e-01F, 6.079498e-01F, 6.103828e-01F, 6.128101e-01F, 6.152316e-01F, 
6.176473e-01F, 6.200572e-01F, 6.224613e-01F, 6.248595e-01F, 6.272518e-01F, 6.296382e-01F, 6.320187e-01F, 6.343933e-01F, 
6.367618e-01F, 6.391244e-01F, 6.414810e-01F, 6.438315e-01F, 6.461760e-01F, 6.485144e-01F, 6.508467e-01F, 6.531728e-01F, 
6.554928e-01F, 6.578067e-01F, 6.601143e-01F, 6.624158e-01F, 6.647110e-01F, 6.669999e-01F, 6.692826e-01F, 6.715589e-01F, 
6.738290e-01F, 6.760927e-01F, 6.783500e-01F, 6.806010e-01F, 6.828455e-01F, 6.850836e-01F, 6.873153e-01F, 6.895405e-01F, 
6.917592e-01F, 6.939714e-01F, 6.961771e-01F, 6.983762e-01F, 7.005688e-01F, 7.027547e-01F, 7.049341e-01F, 7.071068e-01F, 
7.092728e-01F, 7.114322e-01F, 7.135848e-01F, 7.157308e-01F, 7.178700e-01F, 7.200025e-01F, 7.221282e-01F, 7.242471e-01F, 
7.263591e-01F, 7.284644e-01F, 7.305627e-01F, 7.326542e-01F, 7.347389e-01F, 7.368165e-01F, 7.388873e-01F, 7.409511e-01F, 
7.430079e-01F, 7.450578e-01F, 7.471006e-01F, 7.491364e-01F, 7.511651e-01F, 7.531868e-01F, 7.552013e-01F, 7.572088e-01F, 
7.592092e-01F, 7.612024e-01F, 7.631884e-01F, 7.651672e-01F, 7.671389e-01F, 7.691033e-01F, 7.710605e-01F, 7.730104e-01F, 
7.749531e-01F, 7.768884e-01F, 7.788165e-01F, 7.807372e-01F, 7.826506e-01F, 7.845566e-01F, 7.864552e-01F, 7.883464e-01F, 
7.902302e-01F, 7.921066e-01F, 7.939755e-01F, 7.958369e-01F, 7.976908e-01F, 7.995372e-01F, 8.013761e-01F, 8.032075e-01F, 
8.050313e-01F, 8.068475e-01F, 8.086562e-01F, 8.104572e-01F, 8.122506e-01F, 8.140363e-01F, 8.158144e-01F, 8.175848e-01F, 
8.193475e-01F, 8.211025e-01F, 8.228498e-01F, 8.245893e-01F, 8.263210e-01F, 8.280450e-01F, 8.297612e-01F, 8.314696e-01F, 
8.331701e-01F, 8.348628e-01F, 8.365477e-01F, 8.382247e-01F, 8.398938e-01F, 8.415550e-01F, 8.432082e-01F, 8.448535e-01F, 
8.464909e-01F, 8.481203e-01F, 8.497417e-01F, 8.513552e-01F, 8.529606e-01F, 8.545580e-01F, 8.561473e-01F, 8.577286e-01F, 
8.593018e-01F, 8.608669e-01F, 8.624239e-01F, 8.639728e-01F, 8.655136e-01F, 8.670462e-01F, 8.685707e-01F, 8.700870e-01F, 
8.715951e-01F, 8.730950e-01F, 8.745866e-01F, 8.760701e-01F, 8.775453e-01F, 8.790122e-01F, 8.804709e-01F, 8.819212e-01F, 
8.833633e-01F, 8.847971e-01F, 8.862225e-01F, 8.876396e-01F, 8.890483e-01F, 8.904487e-01F, 8.918407e-01F, 8.932243e-01F, 
8.945995e-01F, 8.959662e-01F, 8.973246e-01F, 8.986744e-01F, 9.000159e-01F, 9.013488e-01F, 9.026733e-01F, 9.039893e-01F, 
9.052967e-01F, 9.065957e-01F, 9.078861e-01F, 9.091680e-01F, 9.104413e-01F, 9.117060e-01F, 9.129622e-01F, 9.142097e-01F, 
9.154487e-01F, 9.166790e-01F, 9.179008e-01F, 9.191138e-01F, 9.203183e-01F, 9.215140e-01F, 9.227011e-01F, 9.238795e-01F, 
9.250492e-01F, 9.262102e-01F, 9.273625e-01F, 9.285061e-01F, 9.296409e-01F, 9.307669e-01F, 9.318842e-01F, 9.329928e-01F, 
9.340925e-01F, 9.351835e-01F, 9.362656e-01F, 9.373390e-01F, 9.384035e-01F, 9.394592e-01F, 9.405061e-01F, 9.415440e-01F, 
9.425732e-01F, 9.435934e-01F, 9.446048e-01F, 9.456073e-01F, 9.466009e-01F, 9.475856e-01F, 9.485613e-01F, 9.495282e-01F, 
9.504861e-01F, 9.514350e-01F, 9.523750e-01F, 9.533060e-01F, 9.542281e-01F, 9.551411e-01F, 9.560452e-01F, 9.569403e-01F, 
9.578264e-01F, 9.587035e-01F, 9.595715e-01F, 9.604305e-01F, 9.612805e-01F, 9.621214e-01F, 9.629532e-01F, 9.637760e-01F, 
9.645898e-01F, 9.653944e-01F, 9.661900e-01F, 9.669765e-01F, 9.677538e-01F, 9.685221e-01F, 9.692812e-01F, 9.700312e-01F, 
9.707721e-01F, 9.715039e-01F, 9.722265e-01F, 9.729399e-01F, 9.736442e-01F, 9.743394e-01F, 9.750253e-01F, 9.757021e-01F, 
9.763697e-01F, 9.770281e-01F, 9.776773e-01F, 9.783174e-01F, 9.789482e-01F, 9.795698e-01F, 9.801821e-01F, 9.807853e-01F, 
9.813792e-01F, 9.819639e-01F, 9.825393e-01F, 9.831055e-01F, 9.836624e-01F, 9.842101e-01F, 9.847485e-01F, 9.852776e-01F, 
9.857975e-01F, 9.863081e-01F, 9.868094e-01F, 9.873014e-01F, 9.877841e-01F, 9.882576e-01F, 9.887217e-01F, 9.891765e-01F, 
9.896220e-01F, 9.900582e-01F, 9.904851e-01F, 9.909026e-01F, 9.913109e-01F, 9.917097e-01F, 9.920993e-01F, 9.924795e-01F, 
9.928504e-01F, 9.932119e-01F, 9.935641e-01F, 9.939070e-01F, 9.942404e-01F, 9.945646e-01F, 9.948793e-01F, 9.951847e-01F, 
9.954807e-01F, 9.957674e-01F, 9.960447e-01F, 9.963126e-01F, 9.965711e-01F, 9.968203e-01F, 9.970601e-01F, 9.972905e-01F, 
9.975115e-01F, 9.977231e-01F, 9.979253e-01F, 9.981181e-01F, 9.983015e-01F, 9.984756e-01F, 9.986402e-01F, 9.987955e-01F, 
9.989413e-01F, 9.990777e-01F, 9.992048e-01F, 9.993224e-01F, 9.994306e-01F, 9.995294e-01F, 9.996188e-01F, 9.996988e-01F, 
9.997694e-01F, 9.998306e-01F, 9.998823e-01F, 9.999247e-01F, 9.999576e-01F, 9.999812e-01F, 9.999953e-01F, 1.000000e-00F, 
9.999953e-01F, 9.999812e-01F, 9.999576e-01F, 9.999247e-01F, 9.998823e-01F, 9.998306e-01F, 9.997694e-01F, 9.996988e-01F, 
9.996188e-01F, 9.995294e-01F, 9.994306e-01F, 9.993224e-01F, 9.992048e-01F, 9.990777e-01F, 9.989413e-01F, 9.987955e-01F, 
9.986402e-01F, 9.984756e-01F, 9.983015e-01F, 9.981181e-01F, 9.979253e-01F, 9.977231e-01F, 9.975115e-01F, 9.972905e-01F, 
9.970601e-01F, 9.968203e-01F, 9.965712e-01F, 9.963126e-01F, 9.960447e-01F, 9.957674e-01F, 9.954808e-01F, 9.951847e-01F, 
9.948793e-01F, 9.945646e-01F, 9.942405e-01F, 9.939070e-01F, 9.935641e-01F, 9.932120e-01F, 9.928504e-01F, 9.924795e-01F, 
9.920993e-01F, 9.917098e-01F, 9.913109e-01F, 9.909026e-01F, 9.904851e-01F, 9.900582e-01F, 9.896220e-01F, 9.891765e-01F, 
9.887217e-01F, 9.882576e-01F, 9.877842e-01F, 9.873014e-01F, 9.868094e-01F, 9.863081e-01F, 9.857975e-01F, 9.852777e-01F, 
9.847485e-01F, 9.842101e-01F, 9.836624e-01F, 9.831055e-01F, 9.825393e-01F, 9.819639e-01F, 9.813792e-01F, 9.807853e-01F, 
9.801822e-01F, 9.795698e-01F, 9.789482e-01F, 9.783174e-01F, 9.776774e-01F, 9.770282e-01F, 9.763698e-01F, 9.757021e-01F, 
9.750254e-01F, 9.743394e-01F, 9.736443e-01F, 9.729400e-01F, 9.722265e-01F, 9.715039e-01F, 9.707722e-01F, 9.700313e-01F, 
9.692813e-01F, 9.685221e-01F, 9.677539e-01F, 9.669765e-01F, 9.661900e-01F, 9.653945e-01F, 9.645898e-01F, 9.637761e-01F, 
9.629533e-01F, 9.621214e-01F, 9.612805e-01F, 9.604305e-01F, 9.595715e-01F, 9.587035e-01F, 9.578264e-01F, 9.569404e-01F, 
9.560453e-01F, 9.551412e-01F, 9.542281e-01F, 9.533061e-01F, 9.523750e-01F, 9.514350e-01F, 9.504861e-01F, 9.495282e-01F, 
9.485614e-01F, 9.475856e-01F, 9.466009e-01F, 9.456074e-01F, 9.446049e-01F, 9.435935e-01F, 9.425732e-01F, 9.415441e-01F, 
9.405061e-01F, 9.394593e-01F, 9.384036e-01F, 9.373390e-01F, 9.362657e-01F, 9.351835e-01F, 9.340926e-01F, 9.329928e-01F, 
9.318843e-01F, 9.307670e-01F, 9.296409e-01F, 9.285061e-01F, 9.273626e-01F, 9.262103e-01F, 9.250493e-01F, 9.238796e-01F, 
9.227012e-01F, 9.215141e-01F, 9.203183e-01F, 9.191139e-01F, 9.179008e-01F, 9.166791e-01F, 9.154488e-01F, 9.142098e-01F, 
9.129622e-01F, 9.117061e-01F, 9.104413e-01F, 9.091680e-01F, 9.078862e-01F, 9.065957e-01F, 9.052968e-01F, 9.039893e-01F, 
9.026734e-01F, 9.013489e-01F, 9.000159e-01F, 8.986745e-01F, 8.973246e-01F, 8.959663e-01F, 8.945995e-01F, 8.932243e-01F, 
8.918408e-01F, 8.904488e-01F, 8.890484e-01F, 8.876397e-01F, 8.862226e-01F, 8.847971e-01F, 8.833634e-01F, 8.819213e-01F, 
8.804709e-01F, 8.790123e-01F, 8.775453e-01F, 8.760701e-01F, 8.745867e-01F, 8.730950e-01F, 8.715951e-01F, 8.700870e-01F, 
8.685708e-01F, 8.670463e-01F, 8.655137e-01F, 8.639729e-01F, 8.624240e-01F, 8.608670e-01F, 8.593019e-01F, 8.577287e-01F, 
8.561474e-01F, 8.545580e-01F, 8.529607e-01F, 8.513552e-01F, 8.497418e-01F, 8.481204e-01F, 8.464910e-01F, 8.448536e-01F, 
8.432083e-01F, 8.415550e-01F, 8.398939e-01F, 8.382248e-01F, 8.365478e-01F, 8.348629e-01F, 8.331702e-01F, 8.314697e-01F, 
8.297613e-01F, 8.280451e-01F, 8.263211e-01F, 8.245894e-01F, 8.228498e-01F, 8.211026e-01F, 8.193476e-01F, 8.175849e-01F, 
8.158145e-01F, 8.140364e-01F, 8.122506e-01F, 8.104573e-01F, 8.086562e-01F, 8.068476e-01F, 8.050314e-01F, 8.032076e-01F, 
8.013762e-01F, 7.995373e-01F, 7.976909e-01F, 7.958370e-01F, 7.939755e-01F, 7.921066e-01F, 7.902303e-01F, 7.883465e-01F, 
7.864553e-01F, 7.845567e-01F, 7.826507e-01F, 7.807373e-01F, 7.788166e-01F, 7.768885e-01F, 7.749532e-01F, 7.730105e-01F, 
7.710606e-01F, 7.691034e-01F, 7.671390e-01F, 7.651673e-01F, 7.631885e-01F, 7.612025e-01F, 7.592093e-01F, 7.572089e-01F, 
7.552015e-01F, 7.531869e-01F, 7.511652e-01F, 7.491365e-01F, 7.471007e-01F, 7.450579e-01F, 7.430080e-01F, 7.409512e-01F, 
7.388874e-01F, 7.368166e-01F, 7.347390e-01F, 7.326543e-01F, 7.305628e-01F, 7.284645e-01F, 7.263592e-01F, 7.242472e-01F, 
7.221283e-01F, 7.200026e-01F, 7.178701e-01F, 7.157309e-01F, 7.135849e-01F, 7.114323e-01F, 7.092729e-01F, 7.071069e-01F, 
7.049342e-01F, 7.027548e-01F, 7.005689e-01F, 6.983763e-01F, 6.961772e-01F, 6.939715e-01F, 6.917593e-01F, 6.895406e-01F, 
6.873154e-01F, 6.850838e-01F, 6.828456e-01F, 6.806011e-01F, 6.783501e-01F, 6.760928e-01F, 6.738291e-01F, 6.715590e-01F, 
6.692827e-01F, 6.670000e-01F, 6.647111e-01F, 6.624159e-01F, 6.601144e-01F, 6.578068e-01F, 6.554929e-01F, 6.531729e-01F, 
6.508468e-01F, 6.485145e-01F, 6.461761e-01F, 6.438316e-01F, 6.414811e-01F, 6.391245e-01F, 6.367620e-01F, 6.343934e-01F, 
6.320188e-01F, 6.296383e-01F, 6.272519e-01F, 6.248596e-01F, 6.224614e-01F, 6.200573e-01F, 6.176474e-01F, 6.152317e-01F, 
6.128102e-01F, 6.103829e-01F, 6.079499e-01F, 6.055111e-01F, 6.030667e-01F, 6.006166e-01F, 5.981608e-01F, 5.956994e-01F, 
5.932324e-01F, 5.907598e-01F, 5.882816e-01F, 5.857980e-01F, 5.833088e-01F, 5.808141e-01F, 5.783139e-01F, 5.758083e-01F, 
5.732973e-01F, 5.707808e-01F, 5.682591e-01F, 5.657319e-01F, 5.631994e-01F, 5.606617e-01F, 5.581186e-01F, 5.555703e-01F, 
5.530168e-01F, 5.504581e-01F, 5.478942e-01F, 5.453251e-01F, 5.427509e-01F, 5.401716e-01F, 5.375872e-01F, 5.349977e-01F, 
5.324032e-01F, 5.298037e-01F, 5.271992e-01F, 5.245898e-01F, 5.219754e-01F, 5.193561e-01F, 5.167319e-01F, 5.141029e-01F, 
5.114690e-01F, 5.088303e-01F, 5.061868e-01F, 5.035385e-01F, 5.008855e-01F, 4.982278e-01F, 4.955654e-01F, 4.928983e-01F, 
4.902266e-01F, 4.875503e-01F, 4.848694e-01F, 4.821839e-01F, 4.794939e-01F, 4.767993e-01F, 4.741003e-01F, 4.713969e-01F, 
4.686889e-01F, 4.659766e-01F, 4.632599e-01F, 4.605388e-01F, 4.578134e-01F, 4.550837e-01F, 4.523497e-01F, 4.496114e-01F, 
4.468690e-01F, 4.441223e-01F, 4.413714e-01F, 4.386164e-01F, 4.358572e-01F, 4.330939e-01F, 4.303266e-01F, 4.275552e-01F, 
4.247798e-01F, 4.220004e-01F, 4.192170e-01F, 4.164297e-01F, 4.136384e-01F, 4.108433e-01F, 4.080443e-01F, 4.052414e-01F, 
4.024348e-01F, 3.996243e-01F, 3.968101e-01F, 3.939922e-01F, 3.911705e-01F, 3.883452e-01F, 3.855162e-01F, 3.826836e-01F, 
3.798473e-01F, 3.770075e-01F, 3.741642e-01F, 3.713173e-01F, 3.684670e-01F, 3.656131e-01F, 3.627559e-01F, 3.598952e-01F, 
3.570311e-01F, 3.541637e-01F, 3.512929e-01F, 3.484188e-01F, 3.455415e-01F, 3.426608e-01F, 3.397770e-01F, 3.368900e-01F, 
3.339998e-01F, 3.311064e-01F, 3.282100e-01F, 3.253104e-01F, 3.224078e-01F, 3.195022e-01F, 3.165935e-01F, 3.136819e-01F, 
3.107673e-01F, 3.078498e-01F, 3.049294e-01F, 3.020061e-01F, 2.990800e-01F, 2.961510e-01F, 2.932193e-01F, 2.902848e-01F, 
2.873476e-01F, 2.844077e-01F, 2.814651e-01F, 2.785198e-01F, 2.755720e-01F, 2.726215e-01F, 2.696685e-01F, 2.667129e-01F, 
2.637548e-01F, 2.607943e-01F, 2.578312e-01F, 2.548658e-01F, 2.518980e-01F, 2.489277e-01F, 2.459552e-01F, 2.429803e-01F, 
2.400032e-01F, 2.370237e-01F, 2.340421e-01F, 2.310582e-01F, 2.280722e-01F, 2.250841e-01F, 2.220938e-01F, 2.191014e-01F, 
2.161069e-01F, 2.131105e-01F, 2.101120e-01F, 2.071115e-01F, 2.041091e-01F, 2.011048e-01F, 1.980986e-01F, 1.950905e-01F, 
1.920805e-01F, 1.890688e-01F, 1.860553e-01F, 1.830400e-01F, 1.800230e-01F, 1.770044e-01F, 1.739840e-01F, 1.709620e-01F, 
1.679384e-01F, 1.649133e-01F, 1.618865e-01F, 1.588583e-01F, 1.558285e-01F, 1.527973e-01F, 1.497647e-01F, 1.467306e-01F, 
1.436952e-01F, 1.406584e-01F, 1.376203e-01F, 1.345809e-01F, 1.315402e-01F, 1.284983e-01F, 1.254551e-01F, 1.224108e-01F, 
1.193654e-01F, 1.163188e-01F, 1.132711e-01F, 1.102224e-01F, 1.071726e-01F, 1.041218e-01F, 1.010700e-01F, 9.801729e-02F, 
9.496364e-02F, 9.190910e-02F, 8.885370e-02F, 8.579746e-02F, 8.274041e-02F, 7.968259e-02F, 7.662401e-02F, 7.356471e-02F, 
7.050472e-02F, 6.744407e-02F, 6.438278e-02F, 6.132089e-02F, 5.825841e-02F, 5.519540e-02F, 5.213186e-02F, 4.906783e-02F, 
4.600333e-02F, 4.293841e-02F, 3.987308e-02F, 3.680737e-02F, 3.374132e-02F, 3.067496e-02F, 2.760830e-02F, 2.454138e-02F, 
2.147423e-02F, 1.840688e-02F, 1.533936e-02F, 1.227169e-02F, 9.203908e-03F, 6.136038e-03F, 3.068110e-03F, 1.535898e-07F, 
-3.067803e-03F, -6.135731e-03F, -9.203601e-03F, -1.227138e-02F, -1.533905e-02F, -1.840658e-02F, -2.147393e-02F, -2.454107e-02F, 
-2.760799e-02F, -3.067465e-02F, -3.374102e-02F, -3.680707e-02F, -3.987277e-02F, -4.293810e-02F, -4.600303e-02F, -4.906752e-02F, 
-5.213155e-02F, -5.519509e-02F, -5.825811e-02F, -6.132058e-02F, -6.438247e-02F, -6.744376e-02F, -7.050442e-02F, -7.356441e-02F, 
-7.662370e-02F, -7.968228e-02F, -8.274011e-02F, -8.579716e-02F, -8.885340e-02F, -9.190880e-02F, -9.496334e-02F, -9.801698e-02F, 
-1.010697e-01F, -1.041215e-01F, -1.071723e-01F, -1.102220e-01F, -1.132708e-01F, -1.163185e-01F, -1.193651e-01F, -1.224105e-01F, 
-1.254548e-01F, -1.284980e-01F, -1.315399e-01F, -1.345805e-01F, -1.376200e-01F, -1.406581e-01F, -1.436949e-01F, -1.467303e-01F, 
-1.497644e-01F, -1.527970e-01F, -1.558282e-01F, -1.588580e-01F, -1.618862e-01F, -1.649130e-01F, -1.679381e-01F, -1.709617e-01F, 
-1.739837e-01F, -1.770041e-01F, -1.800227e-01F, -1.830397e-01F, -1.860550e-01F, -1.890685e-01F, -1.920802e-01F, -1.950902e-01F, 
-1.980983e-01F, -2.011045e-01F, -2.041088e-01F, -2.071112e-01F, -2.101117e-01F, -2.131102e-01F, -2.161066e-01F, -2.191011e-01F, 
-2.220935e-01F, -2.250838e-01F, -2.280719e-01F, -2.310579e-01F, -2.340418e-01F, -2.370234e-01F, -2.400029e-01F, -2.429800e-01F, 
-2.459549e-01F, -2.489274e-01F, -2.518977e-01F, -2.548655e-01F, -2.578309e-01F, -2.607940e-01F, -2.637545e-01F, -2.667126e-01F, 
-2.696682e-01F, -2.726212e-01F, -2.755717e-01F, -2.785195e-01F, -2.814648e-01F, -2.844074e-01F, -2.873473e-01F, -2.902845e-01F, 
-2.932190e-01F, -2.961507e-01F, -2.990797e-01F, -3.020058e-01F, -3.049291e-01F, -3.078495e-01F, -3.107670e-01F, -3.136816e-01F, 
-3.165932e-01F, -3.195019e-01F, -3.224075e-01F, -3.253101e-01F, -3.282097e-01F, -3.311061e-01F, -3.339995e-01F, -3.368897e-01F, 
-3.397767e-01F, -3.426606e-01F, -3.455412e-01F, -3.484185e-01F, -3.512926e-01F, -3.541634e-01F, -3.570308e-01F, -3.598949e-01F, 
-3.627556e-01F, -3.656128e-01F, -3.684667e-01F, -3.713170e-01F, -3.741639e-01F, -3.770073e-01F, -3.798470e-01F, -3.826833e-01F, 
-3.855159e-01F, -3.883449e-01F, -3.911702e-01F, -3.939919e-01F, -3.968098e-01F, -3.996240e-01F, -4.024345e-01F, -4.052412e-01F, 
-4.080440e-01F, -4.108430e-01F, -4.136382e-01F, -4.164294e-01F, -4.192167e-01F, -4.220001e-01F, -4.247795e-01F, -4.275549e-01F, 
-4.303263e-01F, -4.330937e-01F, -4.358569e-01F, -4.386161e-01F, -4.413711e-01F, -4.441220e-01F, -4.468687e-01F, -4.496112e-01F, 
-4.523494e-01F, -4.550834e-01F, -4.578131e-01F, -4.605386e-01F, -4.632596e-01F, -4.659763e-01F, -4.686887e-01F, -4.713966e-01F, 
-4.741001e-01F, -4.767991e-01F, -4.794936e-01F, -4.821836e-01F, -4.848691e-01F, -4.875500e-01F, -4.902263e-01F, -4.928980e-01F, 
-4.955651e-01F, -4.982275e-01F, -5.008852e-01F, -5.035382e-01F, -5.061865e-01F, -5.088300e-01F, -5.114687e-01F, -5.141026e-01F, 
-5.167316e-01F, -5.193558e-01F, -5.219751e-01F, -5.245895e-01F, -5.271990e-01F, -5.298035e-01F, -5.324030e-01F, -5.349975e-01F, 
-5.375869e-01F, -5.401713e-01F, -5.427506e-01F, -5.453248e-01F, -5.478939e-01F, -5.504578e-01F, -5.530166e-01F, -5.555701e-01F, 
-5.581184e-01F, -5.606614e-01F, -5.631992e-01F, -5.657317e-01F, -5.682588e-01F, -5.707806e-01F, -5.732970e-01F, -5.758080e-01F, 
-5.783136e-01F, -5.808138e-01F, -5.833085e-01F, -5.857977e-01F, -5.882814e-01F, -5.907596e-01F, -5.932321e-01F, -5.956992e-01F, 
-5.981606e-01F, -6.006163e-01F, -6.030665e-01F, -6.055109e-01F, -6.079496e-01F, -6.103827e-01F, -6.128099e-01F, -6.152314e-01F, 
-6.176472e-01F, -6.200571e-01F, -6.224611e-01F, -6.248593e-01F, -6.272517e-01F, -6.296381e-01F, -6.320186e-01F, -6.343931e-01F, 
-6.367617e-01F, -6.391243e-01F, -6.414809e-01F, -6.438314e-01F, -6.461759e-01F, -6.485143e-01F, -6.508465e-01F, -6.531727e-01F, 
-6.554927e-01F, -6.578066e-01F, -6.601142e-01F, -6.624156e-01F, -6.647108e-01F, -6.669998e-01F, -6.692824e-01F, -6.715588e-01F, 
-6.738289e-01F, -6.760926e-01F, -6.783499e-01F, -6.806009e-01F, -6.828454e-01F, -6.850835e-01F, -6.873152e-01F, -6.895404e-01F, 
-6.917591e-01F, -6.939713e-01F, -6.961770e-01F, -6.983761e-01F, -7.005687e-01F, -7.027546e-01F, -7.049339e-01F, -7.071066e-01F, 
-7.092727e-01F, -7.114321e-01F, -7.135847e-01F, -7.157307e-01F, -7.178699e-01F, -7.200024e-01F, -7.221281e-01F, -7.242469e-01F, 
-7.263590e-01F, -7.284643e-01F, -7.305626e-01F, -7.326541e-01F, -7.347387e-01F, -7.368164e-01F, -7.388872e-01F, -7.409510e-01F, 
-7.430078e-01F, -7.450577e-01F, -7.471005e-01F, -7.491363e-01F, -7.511650e-01F, -7.531867e-01F, -7.552012e-01F, -7.572087e-01F, 
-7.592091e-01F, -7.612023e-01F, -7.631883e-01F, -7.651671e-01F, -7.671388e-01F, -7.691032e-01F, -7.710604e-01F, -7.730103e-01F, 
-7.749530e-01F, -7.768883e-01F, -7.788164e-01F, -7.807371e-01F, -7.826505e-01F, -7.845565e-01F, -7.864551e-01F, -7.883463e-01F, 
-7.902301e-01F, -7.921065e-01F, -7.939754e-01F, -7.958368e-01F, -7.976907e-01F, -7.995371e-01F, -8.013761e-01F, -8.032074e-01F, 
-8.050312e-01F, -8.068474e-01F, -8.086561e-01F, -8.104571e-01F, -8.122505e-01F, -8.140362e-01F, -8.158143e-01F, -8.175847e-01F, 
-8.193474e-01F, -8.211024e-01F, -8.228497e-01F, -8.245892e-01F, -8.263209e-01F, -8.280449e-01F, -8.297611e-01F, -8.314695e-01F, 
-8.331701e-01F, -8.348628e-01F, -8.365476e-01F, -8.382246e-01F, -8.398937e-01F, -8.415549e-01F, -8.432081e-01F, -8.448535e-01F, 
-8.464908e-01F, -8.481202e-01F, -8.497417e-01F, -8.513551e-01F, -8.529605e-01F, -8.545579e-01F, -8.561472e-01F, -8.577285e-01F, 
-8.593017e-01F, -8.608668e-01F, -8.624239e-01F, -8.639728e-01F, -8.655135e-01F, -8.670461e-01F, -8.685706e-01F, -8.700869e-01F, 
-8.715950e-01F, -8.730949e-01F, -8.745866e-01F, -8.760700e-01F, -8.775452e-01F, -8.790121e-01F, -8.804708e-01F, -8.819212e-01F, 
-8.833632e-01F, -8.847970e-01F, -8.862224e-01F, -8.876395e-01F, -8.890483e-01F, -8.904486e-01F, -8.918406e-01F, -8.932242e-01F, 
-8.945994e-01F, -8.959662e-01F, -8.973245e-01F, -8.986744e-01F, -9.000158e-01F, -9.013488e-01F, -9.026732e-01F, -9.039892e-01F, 
-9.052967e-01F, -9.065956e-01F, -9.078860e-01F, -9.091679e-01F, -9.104412e-01F, -9.117059e-01F, -9.129621e-01F, -9.142097e-01F, 
-9.154486e-01F, -9.166790e-01F, -9.179007e-01F, -9.191138e-01F, -9.203182e-01F, -9.215140e-01F, -9.227010e-01F, -9.238795e-01F, 
-9.250492e-01F, -9.262102e-01F, -9.273624e-01F, -9.285060e-01F, -9.296408e-01F, -9.307669e-01F, -9.318842e-01F, -9.329927e-01F, 
-9.340925e-01F, -9.351834e-01F, -9.362656e-01F, -9.373389e-01F, -9.384035e-01F, -9.394592e-01F, -9.405060e-01F, -9.415440e-01F, 
-9.425731e-01F, -9.435934e-01F, -9.446048e-01F, -9.456073e-01F, -9.466008e-01F, -9.475855e-01F, -9.485613e-01F, -9.495281e-01F, 
-9.504860e-01F, -9.514350e-01F, -9.523749e-01F, -9.533060e-01F, -9.542280e-01F, -9.551411e-01F, -9.560452e-01F, -9.569403e-01F, 
-9.578264e-01F, -9.587034e-01F, -9.595715e-01F, -9.604305e-01F, -9.612804e-01F, -9.621213e-01F, -9.629532e-01F, -9.637760e-01F, 
-9.645897e-01F, -9.653944e-01F, -9.661899e-01F, -9.669764e-01F, -9.677538e-01F, -9.685220e-01F, -9.692812e-01F, -9.700312e-01F, 
-9.707721e-01F, -9.715038e-01F, -9.722264e-01F, -9.729399e-01F, -9.736442e-01F, -9.743393e-01F, -9.750253e-01F, -9.757021e-01F, 
-9.763697e-01F, -9.770281e-01F, -9.776773e-01F, -9.783173e-01F, -9.789481e-01F, -9.795697e-01F, -9.801821e-01F, -9.807852e-01F, 
-9.813792e-01F, -9.819638e-01F, -9.825393e-01F, -9.831054e-01F, -9.836624e-01F, -9.842101e-01F, -9.847485e-01F, -9.852776e-01F, 
-9.857975e-01F, -9.863081e-01F, -9.868094e-01F, -9.873014e-01F, -9.877841e-01F, -9.882575e-01F, -9.887217e-01F, -9.891765e-01F, 
-9.896220e-01F, -9.900582e-01F, -9.904851e-01F, -9.909026e-01F, -9.913108e-01F, -9.917097e-01F, -9.920993e-01F, -9.924795e-01F, 
-9.928504e-01F, -9.932119e-01F, -9.935641e-01F, -9.939069e-01F, -9.942404e-01F, -9.945645e-01F, -9.948793e-01F, -9.951847e-01F, 
-9.954807e-01F, -9.957674e-01F, -9.960447e-01F, -9.963126e-01F, -9.965711e-01F, -9.968203e-01F, -9.970601e-01F, -9.972904e-01F, 
-9.975114e-01F, -9.977231e-01F, -9.979253e-01F, -9.981181e-01F, -9.983015e-01F, -9.984756e-01F, -9.986402e-01F, -9.987954e-01F, 
-9.989413e-01F, -9.990777e-01F, -9.992047e-01F, -9.993224e-01F, -9.994306e-01F, -9.995294e-01F, -9.996188e-01F, -9.996988e-01F, 
-9.997694e-01F, -9.998306e-01F, -9.998823e-01F, -9.999247e-01F, -9.999576e-01F, -9.999812e-01F, -9.999953e-01F, -1.000000e-00F, 
-9.999953e-01F, -9.999812e-01F, -9.999576e-01F, -9.999247e-01F, -9.998824e-01F, -9.998306e-01F, -9.997694e-01F, -9.996988e-01F, 
-9.996188e-01F, -9.995294e-01F, -9.994306e-01F, -9.993224e-01F, -9.992048e-01F, -9.990777e-01F, -9.989413e-01F, -9.987955e-01F, 
-9.986402e-01F, -9.984756e-01F, -9.983016e-01F, -9.981181e-01F, -9.979253e-01F, -9.977231e-01F, -9.975115e-01F, -9.972905e-01F, 
-9.970601e-01F, -9.968203e-01F, -9.965712e-01F, -9.963126e-01F, -9.960447e-01F, -9.957674e-01F, -9.954808e-01F, -9.951847e-01F, 
-9.948794e-01F, -9.945646e-01F, -9.942405e-01F, -9.939070e-01F, -9.935642e-01F, -9.932120e-01F, -9.928504e-01F, -9.924796e-01F, 
-9.920993e-01F, -9.917098e-01F, -9.913109e-01F, -9.909027e-01F, -9.904851e-01F, -9.900582e-01F, -9.896221e-01F, -9.891765e-01F, 
-9.887217e-01F, -9.882576e-01F, -9.877842e-01F, -9.873015e-01F, -9.868094e-01F, -9.863081e-01F, -9.857975e-01F, -9.852777e-01F, 
-9.847485e-01F, -9.842101e-01F, -9.836625e-01F, -9.831055e-01F, -9.825393e-01F, -9.819639e-01F, -9.813792e-01F, -9.807853e-01F, 
-9.801822e-01F, -9.795698e-01F, -9.789482e-01F, -9.783174e-01F, -9.776774e-01F, -9.770282e-01F, -9.763698e-01F, -9.757022e-01F, 
-9.750254e-01F, -9.743394e-01F, -9.736443e-01F, -9.729400e-01F, -9.722266e-01F, -9.715039e-01F, -9.707722e-01F, -9.700313e-01F, 
-9.692813e-01F, -9.685222e-01F, -9.677539e-01F, -9.669765e-01F, -9.661901e-01F, -9.653945e-01F, -9.645899e-01F, -9.637761e-01F, 
-9.629533e-01F, -9.621215e-01F, -9.612806e-01F, -9.604306e-01F, -9.595716e-01F, -9.587035e-01F, -9.578265e-01F, -9.569404e-01F, 
-9.560453e-01F, -9.551412e-01F, -9.542282e-01F, -9.533061e-01F, -9.523751e-01F, -9.514351e-01F, -9.504862e-01F, -9.495283e-01F, 
-9.485614e-01F, -9.475857e-01F, -9.466010e-01F, -9.456074e-01F, -9.446049e-01F, -9.435935e-01F, -9.425733e-01F, -9.415441e-01F, 
-9.405062e-01F, -9.394593e-01F, -9.384036e-01F, -9.373391e-01F, -9.362658e-01F, -9.351836e-01F, -9.340926e-01F, -9.329929e-01F, 
-9.318844e-01F, -9.307671e-01F, -9.296410e-01F, -9.285062e-01F, -9.273626e-01F, -9.262103e-01F, -9.250493e-01F, -9.238796e-01F, 
-9.227012e-01F, -9.215141e-01F, -9.203184e-01F, -9.191140e-01F, -9.179009e-01F, -9.166792e-01F, -9.154488e-01F, -9.142099e-01F, 
-9.129623e-01F, -9.117061e-01F, -9.104414e-01F, -9.091681e-01F, -9.078862e-01F, -9.065958e-01F, -9.052969e-01F, -9.039894e-01F, 
-9.026734e-01F, -9.013490e-01F, -9.000160e-01F, -8.986746e-01F, -8.973247e-01F, -8.959664e-01F, -8.945996e-01F, -8.932244e-01F, 
-8.918408e-01F, -8.904488e-01F, -8.890485e-01F, -8.876397e-01F, -8.862226e-01F, -8.847972e-01F, -8.833635e-01F, -8.819214e-01F, 
-8.804710e-01F, -8.790123e-01F, -8.775454e-01F, -8.760702e-01F, -8.745868e-01F, -8.730951e-01F, -8.715952e-01F, -8.700871e-01F, 
-8.685708e-01F, -8.670464e-01F, -8.655138e-01F, -8.639730e-01F, -8.624241e-01F, -8.608671e-01F, -8.593019e-01F, -8.577287e-01F, 
-8.561475e-01F, -8.545581e-01F, -8.529607e-01F, -8.513553e-01F, -8.497419e-01F, -8.481205e-01F, -8.464911e-01F, -8.448537e-01F, 
-8.432084e-01F, -8.415551e-01F, -8.398939e-01F, -8.382248e-01F, -8.365479e-01F, -8.348630e-01F, -8.331703e-01F, -8.314698e-01F, 
-8.297614e-01F, -8.280452e-01F, -8.263212e-01F, -8.245894e-01F, -8.228499e-01F, -8.211027e-01F, -8.193477e-01F, -8.175850e-01F, 
-8.158146e-01F, -8.140365e-01F, -8.122507e-01F, -8.104574e-01F, -8.086563e-01F, -8.068477e-01F, -8.050315e-01F, -8.032077e-01F, 
-8.013763e-01F, -7.995374e-01F, -7.976910e-01F, -7.958371e-01F, -7.939756e-01F, -7.921067e-01F, -7.902304e-01F, -7.883466e-01F, 
-7.864554e-01F, -7.845568e-01F, -7.826508e-01F, -7.807374e-01F, -7.788167e-01F, -7.768886e-01F, -7.749533e-01F, -7.730106e-01F, 
-7.710607e-01F, -7.691035e-01F, -7.671391e-01F, -7.651674e-01F, -7.631886e-01F, -7.612026e-01F, -7.592094e-01F, -7.572090e-01F, 
-7.552016e-01F, -7.531870e-01F, -7.511653e-01F, -7.491366e-01F, -7.471008e-01F, -7.450580e-01F, -7.430081e-01F, -7.409513e-01F, 
-7.388875e-01F, -7.368167e-01F, -7.347391e-01F, -7.326545e-01F, -7.305630e-01F, -7.284646e-01F, -7.263593e-01F, -7.242473e-01F, 
-7.221284e-01F, -7.200027e-01F, -7.178702e-01F, -7.157310e-01F, -7.135851e-01F, -7.114324e-01F, -7.092730e-01F, -7.071070e-01F, 
-7.049343e-01F, -7.027549e-01F, -7.005690e-01F, -6.983764e-01F, -6.961773e-01F, -6.939717e-01F, -6.917595e-01F, -6.895407e-01F, 
-6.873155e-01F, -6.850839e-01F, -6.828457e-01F, -6.806012e-01F, -6.783502e-01F, -6.760929e-01F, -6.738292e-01F, -6.715592e-01F, 
-6.692828e-01F, -6.670001e-01F, -6.647112e-01F, -6.624160e-01F, -6.601145e-01F, -6.578069e-01F, -6.554931e-01F, -6.531730e-01F, 
-6.508469e-01F, -6.485146e-01F, -6.461762e-01F, -6.438318e-01F, -6.414812e-01F, -6.391247e-01F, -6.367621e-01F, -6.343935e-01F, 
-6.320189e-01F, -6.296385e-01F, -6.272520e-01F, -6.248597e-01F, -6.224615e-01F, -6.200574e-01F, -6.176475e-01F, -6.152318e-01F, 
-6.128103e-01F, -6.103830e-01F, -6.079500e-01F, -6.055113e-01F, -6.030668e-01F, -6.006167e-01F, -5.981609e-01F, -5.956995e-01F, 
-5.932325e-01F, -5.907599e-01F, -5.882818e-01F, -5.857981e-01F, -5.833089e-01F, -5.808142e-01F, -5.783140e-01F, -5.758084e-01F, 
-5.732974e-01F, -5.707810e-01F, -5.682592e-01F, -5.657320e-01F, -5.631996e-01F, -5.606618e-01F, -5.581188e-01F, -5.555705e-01F, 
-5.530169e-01F, -5.504582e-01F, -5.478943e-01F, -5.453252e-01F, -5.427510e-01F, -5.401717e-01F, -5.375873e-01F, -5.349979e-01F, 
-5.324034e-01F, -5.298039e-01F, -5.271994e-01F, -5.245899e-01F, -5.219755e-01F, -5.193562e-01F, -5.167320e-01F, -5.141030e-01F, 
-5.114691e-01F, -5.088304e-01F, -5.061869e-01F, -5.035386e-01F, -5.008856e-01F, -4.982279e-01F, -4.955655e-01F, -4.928984e-01F, 
-4.902267e-01F, -4.875504e-01F, -4.848695e-01F, -4.821840e-01F, -4.794940e-01F, -4.767995e-01F, -4.741005e-01F, -4.713970e-01F, 
-4.686891e-01F, -4.659767e-01F, -4.632600e-01F, -4.605390e-01F, -4.578136e-01F, -4.550838e-01F, -4.523498e-01F, -4.496116e-01F, 
-4.468691e-01F, -4.441224e-01F, -4.413715e-01F, -4.386165e-01F, -4.358573e-01F, -4.330941e-01F, -4.303267e-01F, -4.275554e-01F, 
-4.247799e-01F, -4.220005e-01F, -4.192171e-01F, -4.164298e-01F, -4.136386e-01F, -4.108434e-01F, -4.080444e-01F, -4.052416e-01F, 
-4.024349e-01F, -3.996245e-01F, -3.968103e-01F, -3.939923e-01F, -3.911706e-01F, -3.883453e-01F, -3.855163e-01F, -3.826837e-01F, 
-3.798475e-01F, -3.770077e-01F, -3.741643e-01F, -3.713175e-01F, -3.684671e-01F, -3.656133e-01F, -3.627560e-01F, -3.598953e-01F, 
-3.570312e-01F, -3.541638e-01F, -3.512930e-01F, -3.484190e-01F, -3.455416e-01F, -3.426610e-01F, -3.397772e-01F, -3.368901e-01F, 
-3.339999e-01F, -3.311066e-01F, -3.282101e-01F, -3.253106e-01F, -3.224080e-01F, -3.195023e-01F, -3.165937e-01F, -3.136820e-01F, 
-3.107674e-01F, -3.078499e-01F, -3.049295e-01F, -3.020062e-01F, -2.990801e-01F, -2.961512e-01F, -2.932194e-01F, -2.902850e-01F, 
-2.873477e-01F, -2.844078e-01F, -2.814652e-01F, -2.785200e-01F, -2.755721e-01F, -2.726216e-01F, -2.696686e-01F, -2.667130e-01F, 
-2.637550e-01F, -2.607944e-01F, -2.578314e-01F, -2.548659e-01F, -2.518981e-01F, -2.489279e-01F, -2.459553e-01F, -2.429805e-01F, 
-2.400033e-01F, -2.370239e-01F, -2.340422e-01F, -2.310584e-01F, -2.280724e-01F, -2.250842e-01F, -2.220939e-01F, -2.191015e-01F, 
-2.161071e-01F, -2.131106e-01F, -2.101121e-01F, -2.071117e-01F, -2.041093e-01F, -2.011049e-01F, -1.980987e-01F, -1.950906e-01F, 
-1.920807e-01F, -1.890690e-01F, -1.860554e-01F, -1.830402e-01F, -1.800232e-01F, -1.770045e-01F, -1.739842e-01F, -1.709622e-01F, 
-1.679386e-01F, -1.649134e-01F, -1.618867e-01F, -1.588584e-01F, -1.558287e-01F, -1.527975e-01F, -1.497648e-01F, -1.467308e-01F, 
-1.436953e-01F, -1.406585e-01F, -1.376204e-01F, -1.345810e-01F, -1.315403e-01F, -1.284984e-01F, -1.254553e-01F, -1.224110e-01F, 
-1.193655e-01F, -1.163189e-01F, -1.132713e-01F, -1.102225e-01F, -1.071727e-01F, -1.041219e-01F, -1.010702e-01F, -9.801744e-02F, 
-9.496380e-02F, -9.190926e-02F, -8.885385e-02F, -8.579761e-02F, -8.274057e-02F, -7.968274e-02F, -7.662416e-02F, -7.356487e-02F, 
-7.050488e-02F, -6.744422e-02F, -6.438293e-02F, -6.132104e-02F, -5.825857e-02F, -5.519555e-02F, -5.213201e-02F, -4.906798e-02F, 
-4.600349e-02F, -4.293856e-02F, -3.987323e-02F, -3.680753e-02F, -3.374148e-02F, -3.067511e-02F, -2.760845e-02F, -2.454153e-02F, 
-2.147439e-02F, -1.840704e-02F, -1.533951e-02F, -1.227184e-02F, -9.204061e-03F, -6.136192e-03F, -3.068264e-03F, 0.000000e+00F, 
3.067957e-03F, 6.135884e-03F, 9.203754e-03F, 1.227154e-02F, 1.533921e-02F, 1.840673e-02F, 2.147408e-02F, 2.454123e-02F, 
2.760814e-02F, 3.067480e-02F, 3.374117e-02F, 3.680722e-02F, 3.987293e-02F, 4.293825e-02F, 4.600318e-02F, 4.906767e-02F, 
5.213170e-02F, 5.519524e-02F, 5.825826e-02F, 6.132073e-02F, 6.438263e-02F, 6.744392e-02F, 7.050457e-02F, 7.356456e-02F, 
7.662386e-02F, 7.968243e-02F, 8.274026e-02F, 8.579731e-02F, 8.885355e-02F, 9.190895e-02F, 9.496349e-02F, 9.801714e-02F, 
1.010699e-01F, 1.041216e-01F, 1.071724e-01F, 1.102222e-01F, 1.132709e-01F, 1.163186e-01F, 1.193652e-01F, 1.224107e-01F, 
1.254550e-01F, 1.284981e-01F, 1.315400e-01F, 1.345807e-01F, 1.376201e-01F, 1.406582e-01F, 1.436950e-01F, 1.467305e-01F, 
1.497645e-01F, 1.527972e-01F, 1.558284e-01F, 1.588581e-01F, 1.618864e-01F, 1.649131e-01F, 1.679383e-01F, 1.709619e-01F, 
1.739839e-01F, 1.770042e-01F, 1.800229e-01F, 1.830399e-01F, 1.860551e-01F, 1.890687e-01F, 1.920804e-01F, 1.950903e-01F, 
1.980984e-01F, 2.011046e-01F, 2.041090e-01F, 2.071114e-01F, 2.101118e-01F, 2.131103e-01F, 2.161068e-01F, 2.191012e-01F, 
2.220936e-01F, 2.250839e-01F, 2.280721e-01F, 2.310581e-01F, 2.340419e-01F, 2.370236e-01F, 2.400030e-01F, 2.429802e-01F, 
2.459550e-01F, 2.489276e-01F, 2.518978e-01F, 2.548656e-01F, 2.578311e-01F, 2.607941e-01F, 2.637547e-01F, 2.667127e-01F, 
2.696683e-01F, 2.726213e-01F, 2.755718e-01F, 2.785197e-01F, 2.814649e-01F, 2.844075e-01F, 2.873474e-01F, 2.902847e-01F, 
2.932191e-01F, 2.961509e-01F, 2.990798e-01F, 3.020059e-01F, 3.049292e-01F, 3.078496e-01F, 3.107671e-01F, 3.136817e-01F, 
3.165934e-01F, 3.195020e-01F, 3.224077e-01F, 3.253103e-01F, 3.282098e-01F, 3.311063e-01F, 3.339996e-01F, 3.368898e-01F, 
3.397769e-01F, 3.426607e-01F, 3.455413e-01F, 3.484187e-01F, 3.512927e-01F, 3.541635e-01F, 3.570309e-01F, 3.598950e-01F, 
3.627557e-01F, 3.656130e-01F, 3.684668e-01F, 3.713172e-01F, 3.741640e-01F, 3.770074e-01F, 3.798472e-01F, 3.826834e-01F, 
3.855160e-01F, 3.883450e-01F, 3.911704e-01F, 3.939920e-01F, 3.968100e-01F, 3.996242e-01F, 4.024346e-01F, 4.052413e-01F, 
4.080441e-01F, 4.108432e-01F, 4.136383e-01F, 4.164295e-01F, 4.192169e-01F, 4.220003e-01F, 4.247797e-01F, 4.275551e-01F, 
4.303265e-01F, 4.330938e-01F, 4.358571e-01F, 4.386162e-01F, 4.413712e-01F, 4.441221e-01F, 4.468688e-01F, 4.496113e-01F, 
4.523496e-01F, 4.550836e-01F, 4.578133e-01F, 4.605387e-01F, 4.632598e-01F, 4.659765e-01F, 4.686888e-01F, 4.713967e-01F, 
4.741002e-01F, 4.767992e-01F, 4.794937e-01F, 4.821838e-01F, 4.848692e-01F, 4.875501e-01F, 4.902265e-01F, 4.928982e-01F, 
4.955652e-01F, 4.982276e-01F, 5.008854e-01F, 5.035384e-01F, 5.061866e-01F, 5.088301e-01F, 5.114688e-01F, 5.141027e-01F, 
5.167318e-01F, 5.193560e-01F, 5.219753e-01F, 5.245897e-01F, 5.271991e-01F, 5.298036e-01F, 5.324031e-01F, 5.349976e-01F, 
5.375871e-01F, 5.401714e-01F, 5.427508e-01F, 5.453250e-01F, 5.478940e-01F, 5.504579e-01F, 5.530167e-01F, 5.555702e-01F, 
5.581185e-01F, 5.606616e-01F, 5.631993e-01F, 5.657318e-01F, 5.682589e-01F, 5.707807e-01F, 5.732971e-01F, 5.758082e-01F, 
5.783138e-01F, 5.808139e-01F, 5.833086e-01F, 5.857978e-01F, 5.882815e-01F, 5.907597e-01F, 5.932323e-01F, 5.956993e-01F, 
5.981607e-01F, 6.006165e-01F, 6.030666e-01F, 6.055110e-01F, 6.079498e-01F, 6.103828e-01F, 6.128101e-01F, 6.152316e-01F, 
6.176473e-01F, 6.200572e-01F, 6.224613e-01F, 6.248595e-01F, 6.272518e-01F, 6.296382e-01F, 6.320187e-01F, 6.343933e-01F, 
6.367618e-01F, 6.391244e-01F, 6.414810e-01F, 6.438315e-01F, 6.461760e-01F, 6.485144e-01F, 6.508467e-01F, 6.531728e-01F, 
6.554928e-01F, 6.578067e-01F, 6.601143e-01F, 6.624158e-01F, 6.647110e-01F, 6.669999e-01F, 6.692826e-01F, 6.715589e-01F, 
6.738290e-01F, 6.760927e-01F, 6.783500e-01F, 6.806010e-01F, 6.828455e-01F, 6.850836e-01F, 6.873153e-01F, 6.895405e-01F, 
6.917592e-01F, 6.939714e-01F, 6.961771e-01F, 6.983762e-01F, 7.005688e-01F, 7.027547e-01F, 7.049341e-01F, 7.071068e-01F, 
7.092728e-01F, 7.114322e-01F, 7.135848e-01F, 7.157308e-01F, 7.178700e-01F, 7.200025e-01F, 7.221282e-01F, 7.242471e-01F, 
7.263591e-01F, 7.284644e-01F, 7.305627e-01F, 7.326542e-01F, 7.347389e-01F, 7.368165e-01F, 7.388873e-01F, 7.409511e-01F, 
7.430079e-01F, 7.450578e-01F, 7.471006e-01F, 7.491364e-01F, 7.511651e-01F, 7.531868e-01F, 7.552013e-01F, 7.572088e-01F, 
7.592092e-01F, 7.612024e-01F, 7.631884e-01F, 7.651672e-01F, 7.671389e-01F, 7.691033e-01F, 7.710605e-01F, 7.730104e-01F, 
7.749531e-01F, 7.768884e-01F, 7.788165e-01F, 7.807372e-01F, 7.826506e-01F, 7.845566e-01F, 7.864552e-01F, 7.883464e-01F, 
7.902302e-01F, 7.921066e-01F, 7.939755e-01F, 7.958369e-01F, 7.976908e-01F, 7.995372e-01F, 8.013761e-01F, 8.032075e-01F, 
8.050313e-01F, 8.068475e-01F, 8.086562e-01F, 8.104572e-01F, 8.122506e-01F, 8.140363e-01F, 8.158144e-01F, 8.175848e-01F, 
8.193475e-01F, 8.211025e-01F, 8.228498e-01F, 8.245893e-01F, 8.263210e-01F, 8.280450e-01F, 8.297612e-01F, 8.314696e-01F, 
8.331701e-01F, 8.348628e-01F, 8.365477e-01F, 8.382247e-01F, 8.398938e-01F, 8.415550e-01F, 8.432082e-01F, 8.448535e-01F, 
8.464909e-01F, 8.481203e-01F, 8.497417e-01F, 8.513552e-01F, 8.529606e-01F, 8.545580e-01F, 8.561473e-01F, 8.577286e-01F, 
8.593018e-01F, 8.608669e-01F, 8.624239e-01F, 8.639728e-01F, 8.655136e-01F, 8.670462e-01F, 8.685707e-01F, 8.700870e-01F, 
8.715951e-01F, 8.730950e-01F, 8.745866e-01F, 8.760701e-01F, 8.775453e-01F, 8.790122e-01F, 8.804709e-01F, 8.819212e-01F, 
8.833633e-01F, 8.847971e-01F, 8.862225e-01F, 8.876396e-01F, 8.890483e-01F, 8.904487e-01F, 8.918407e-01F, 8.932243e-01F, 
8.945995e-01F, 8.959662e-01F, 8.973246e-01F, 8.986744e-01F, 9.000159e-01F, 9.013488e-01F, 9.026733e-01F, 9.039893e-01F, 
9.052967e-01F, 9.065957e-01F, 9.078861e-01F, 9.091680e-01F, 9.104413e-01F, 9.117060e-01F, 9.129622e-01F, 9.142097e-01F, 
9.154487e-01F, 9.166790e-01F, 9.179008e-01F, 9.191138e-01F, 9.203183e-01F, 9.215140e-01F, 9.227011e-01F, 9.238795e-01F, 
9.250492e-01F, 9.262102e-01F, 9.273625e-01F, 9.285061e-01F, 9.296409e-01F, 9.307669e-01F, 9.318842e-01F, 9.329928e-01F, 
9.340925e-01F, 9.351835e-01F, 9.362656e-01F, 9.373390e-01F, 9.384035e-01F, 9.394592e-01F, 9.405061e-01F, 9.415440e-01F, 
9.425732e-01F, 9.435934e-01F, 9.446048e-01F, 9.456073e-01F, 9.466009e-01F, 9.475856e-01F, 9.485613e-01F, 9.495282e-01F, 
9.504861e-01F, 9.514350e-01F, 9.523750e-01F, 9.533060e-01F, 9.542281e-01F, 9.551411e-01F, 9.560452e-01F, 9.569403e-01F, 
9.578264e-01F, 9.587035e-01F, 9.595715e-01F, 9.604305e-01F, 9.612805e-01F, 9.621214e-01F, 9.629532e-01F, 9.637760e-01F, 
9.645898e-01F, 9.653944e-01F, 9.661900e-01F, 9.669765e-01F, 9.677538e-01F, 9.685221e-01F, 9.692812e-01F, 9.700312e-01F, 
9.707721e-01F, 9.715039e-01F, 9.722265e-01F, 9.729399e-01F, 9.736442e-01F, 9.743394e-01F, 9.750253e-01F, 9.757021e-01F, 
9.763697e-01F, 9.770281e-01F, 9.776773e-01F, 9.783174e-01F, 9.789482e-01F, 9.795698e-01F, 9.801821e-01F, 9.807853e-01F, 
9.813792e-01F, 9.819639e-01F, 9.825393e-01F, 9.831055e-01F, 9.836624e-01F, 9.842101e-01F, 9.847485e-01F, 9.852776e-01F, 
9.857975e-01F, 9.863081e-01F, 9.868094e-01F, 9.873014e-01F, 9.877841e-01F, 9.882576e-01F, 9.887217e-01F, 9.891765e-01F, 
9.896220e-01F, 9.900582e-01F, 9.904851e-01F, 9.909026e-01F, 9.913109e-01F, 9.917097e-01F, 9.920993e-01F, 9.924795e-01F, 
9.928504e-01F, 9.932119e-01F, 9.935641e-01F, 9.939070e-01F, 9.942404e-01F, 9.945646e-01F, 9.948793e-01F, 9.951847e-01F, 
9.954807e-01F, 9.957674e-01F, 9.960447e-01F, 9.963126e-01F, 9.965711e-01F, 9.968203e-01F, 9.970601e-01F, 9.972905e-01F, 
9.975115e-01F, 9.977231e-01F, 9.979253e-01F, 9.981181e-01F, 9.983015e-01F, 9.984756e-01F, 9.986402e-01F, 9.987955e-01F, 
9.989413e-01F, 9.990777e-01F, 9.992048e-01F, 9.993224e-01F, 9.994306e-01F, 9.995294e-01F, 9.996188e-01F, 9.996988e-01F, 
9.997694e-01F, 9.998306e-01F, 9.998823e-01F, 9.999247e-01F, 9.999576e-01F, 9.999812e-01F, 9.999953e-01F};

#define TSIN(x) sintab[(int)(x)]
#define TCOS(x) sintab[(int)(x)+TRIGQUAD]
#define BUZZDIVISOR 0.02F
#define BUZZMINVAL 0.995F
#define BUZZMAXVAL 1.005F
#define BUS_output_bus 0
#define ENDBUS_output_bus 1
#define ENDBUS 1
float bus[ENDBUS];
float sbus[ENDBUS];

#define CSYS_EXTCHANSTART 0
int midimasterchannel = CSYS_EXTCHANSTART;

/* first 4144 locations for MIDI */
#define GBL_STARTVAR 4144
#define GBL__sym_mtab_0 4144
#define GBL_ENDVAR 4145
/* global variables */

dstack global[GBL_ENDVAR+1];

#define TBL_GBL__sym_mtab_0 0
#define GBL_ENDTBL 1
struct tableinfo gtables[GBL_ENDTBL+1];

#define linbuzz_pitch 0
#define linbuzz_vel 1
#define linbuzz__sym_mtab_0 2
#define linbuzz_fbase 3
#define linbuzz_envc 4
#define linbuzz_fpercent 5
#define linbuzz_offset 6
#define linbuzz_mean 7
#define linbuzz_std 8
#define linbuzz_f 9
#define linbuzz_bright 10
#define linbuzz_volume 11
#define linbuzz_attack 12
#define linbuzz_release 13
#define linbuzz_attlim 14
#define linbuzz_incr 15
#define linbuzz_rel 16
#define linbuzz_tot 17
#define linbuzz_mod 18
#define linbuzz_y 19
#define linbuzz_fsmooth 20
#define linbuzz_init 21
#define linbuzz_env 22
#define linbuzz__tvr1 23
#define linbuzz__tvr0 24
#define linbuzz_int1_return 25
#define linbuzz_int2_return 26
#define linbuzz_cpsmidi3_return 27
#define linbuzz_max4_x1 28
#define linbuzz_max4_return 29
#define linbuzz_min5_x1 30
#define linbuzz_min5_return 31
#define linbuzz_port6_done 32
#define linbuzz_port6_first 33
#define linbuzz_port6_sl 34
#define linbuzz_port6_ohtime 35
#define linbuzz_port6_int 36
#define linbuzz_port6_curr 37
#define linbuzz_port6_new 38
#define linbuzz_port6_htime 39
#define linbuzz_port6_ctrl 40
#define linbuzz_port6_return 41
#define linbuzz_port7_done 42
#define linbuzz_port7_first 43
#define linbuzz_port7_sl 44
#define linbuzz_port7_ohtime 45
#define linbuzz_port7_int 46
#define linbuzz_port7_curr 47
#define linbuzz_port7_new 48
#define linbuzz_port7_htime 49
#define linbuzz_port7_ctrl 50
#define linbuzz_port7_return 51
#define linbuzz_max8_x1 52
#define linbuzz_max8_return 53
#define linbuzz_krand9_return 54
#define linbuzz_koscil10_first 55
#define linbuzz_koscil10_iloops 56
#define linbuzz_koscil10_p 57
#define linbuzz_koscil10_freq 58
#define linbuzz_koscil10_t 59
#define linbuzz_koscil10_return 60
#define linbuzz_port11_done 61
#define linbuzz_port11_first 62
#define linbuzz_port11_sl 63
#define linbuzz_port11_ohtime 64
#define linbuzz_port11_int 65
#define linbuzz_port11_curr 66
#define linbuzz_port11_new 67
#define linbuzz_port11_htime 68
#define linbuzz_port11_ctrl 69
#define linbuzz_port11_return 70
#define linbuzz_max12_x1 71
#define linbuzz_max12_return 72
#define linbuzz_krand13_return 73
#define linbuzz_koscil14_first 74
#define linbuzz_koscil14_iloops 75
#define linbuzz_koscil14_p 76
#define linbuzz_koscil14_freq 77
#define linbuzz_koscil14_t 78
#define linbuzz_koscil14_return 79
#define linbuzz_buzz15_kcyc 80
#define linbuzz_buzz15_k2 81
#define linbuzz_buzz15_k1 82
#define linbuzz_buzz15_d 83
#define linbuzz_buzz15_qtab 84
#define linbuzz_buzz15_ntab 85
#define linbuzz_buzz15_r 86
#define linbuzz_buzz15_scale 87
#define linbuzz_buzz15_p 88
#define linbuzz_buzz15_rolloff 89
#define linbuzz_buzz15_lowharm 90
#define linbuzz_buzz15_nharm 91
#define linbuzz_buzz15_cps 92
#define linbuzz_buzz15_return 93
#define linbuzz_ENDVAR 94

#define TBL_linbuzz__sym_mtab_0 0
#define linbuzz_ENDTBL 1

#define mix1__tvr0 0
#define mix1_port1_done 1
#define mix1_port1_first 2
#define mix1_port1_sl 3
#define mix1_port1_ohtime 4
#define mix1_port1_int 5
#define mix1_port1_curr 6
#define mix1_port1_new 7
#define mix1_port1_htime 8
#define mix1_port1_ctrl 9
#define mix1_port1_return 10
#define mix1_ENDVAR 11

#define mix1_ENDTBL 0

extern void sigint_handler(int);

float linbuzz__sym_max4(struct ninstr_types *);
float linbuzz__sym_min5(struct ninstr_types *);
float linbuzz__sym_port6(struct ninstr_types *);
float linbuzz__sym_port7(struct ninstr_types *);
float linbuzz__sym_max8(struct ninstr_types *);
float linbuzz__sym_koscil10(struct ninstr_types *);
float linbuzz__sym_port11(struct ninstr_types *);
float linbuzz__sym_max12(struct ninstr_types *);
float linbuzz__sym_koscil14(struct ninstr_types *);
float linbuzz__sym_buzz15(struct ninstr_types *);
float mix1__sym_port1(void);
void linbuzz_ipass(struct ninstr_types *);
void linbuzz_kpass(struct ninstr_types *);
void linbuzz_apass(struct ninstr_types *);

void mix1_ipass(void);
void mix1_kpass(void);
void mix1_apass(void);

float finput0(float);
float finGroup0(float);

extern float table_global__sym_mtab_0[];

#define CSYS_GIVENENDTIME 1

#define MAXENDTIME 1E+37

float endtime = 216000.0F;
#define MAXCNOTES 256

#define CSYS_INSTRNUM 2

#define CSYS_IRATE 0
#define CSYS_KRATE 1
#define CSYS_ARATE 2
#define CSYS_TABLE 3

#define CSYS_NORMAL 0
#define CSYS_IMPORT 1
#define CSYS_EXPORT 2
#define CSYS_IMPORTEXPORT 3
#define CSYS_PFIELD 4
#define CSYS_INTERNAL 5

#define CSYS_STATUS_EFFECTS    1 
#define CSYS_STATUS_SCORE      2 
#define CSYS_STATUS_MIDI       4 
#define CSYS_STATUS_DYNAMIC    8 
#define CSYS_STATUS_STARTUP   16 

typedef struct csys_varstruct {
  int index;
  char * name;
  int token;
  int type;
  int tag;
  int width;
} csys_varstruct;

typedef struct csys_instrstruct {
  int index;
  char * name;
  int token;
  int numvars;
  csys_varstruct * vars;
  int outwidth;
  int status;
} csys_instrstruct;

typedef struct csys_labelstruct {
  int index;
  char * name;
  int token;
  int iflag[CSYS_INSTRNUM];
} csys_labelstruct;

typedef struct csys_presetstruct {
  int index;
  int preset;
} csys_presetstruct;

typedef struct csys_samplestruct {
  int index;
  int token;
  char * name;
  char * fname;
} csys_samplestruct;

typedef struct csys_routestruct {
  int bus;
  int ninstr;
  int * instr;
} csys_routestruct;

typedef struct csys_sendstruct {
  int instr;
  int nbus;
  int * bus;
} csys_sendstruct;

typedef struct csys_busstruct {
  int index;
  char * name;
  int width;
  int oflag;
} csys_busstruct;

typedef struct csys_targetstruct {
char * name;
int token;
int numinstr;
int * instrindex;
int * varindex;
} csys_targetstruct;

 float position[3];
 float direction[3];
 float listenerPosition[3];
 float listenerDirection[3];
 float minFront;
 float maxFront;
 float minBack;
 float maxBack;
 float params[128];


void csys_terminate(char * message)
{
   epr(0,NULL,"linmidi control driver", message);
}

#define CSYS_GLOBALNUM 0

csys_varstruct csys_global[1];

#define CSYS_TARGETNUM 0

csys_targetstruct csys_target[1];

#define CSYS_NOLABEL 0

#define CSYS_LABELNUM 0

csys_labelstruct csys_labels[1];

#define CSYS_PRESETNUM 1

csys_presetstruct csys_presets[CSYS_PRESETNUM] = {
0, 0 };

#define CSYS_SAMPLENUM 0

csys_samplestruct csys_samples[1];

#define CSYS_BUSNUM 1

csys_busstruct csys_bus[CSYS_BUSNUM] = {
0, "output_bus",1, 0 };

#define CSYS_ROUTENUM 0

csys_routestruct csys_route[1];

#define CSYS_SEND_BNUM_0 1

int csys_send0_bus[CSYS_SEND_BNUM_0] = {
 0};

#define CSYS_SENDNUM 1

csys_sendstruct csys_send[CSYS_SENDNUM] = {
1, CSYS_SEND_BNUM_0, &(csys_send0_bus[0]) };

#define CSYS_linbuzz_VARNUM 22

csys_varstruct csys_linbuzz_vars[CSYS_linbuzz_VARNUM] = {
0, "pitch", 3, CSYS_IRATE, CSYS_PFIELD, 1 ,
0, "vel", 4, CSYS_IRATE, CSYS_PFIELD, 1 ,
0, "fbase", 7, CSYS_IRATE, CSYS_NORMAL, 1 ,
0, "envc", 8, CSYS_IRATE, CSYS_NORMAL, 1 ,
1, "fpercent", 9, CSYS_IRATE, CSYS_NORMAL, 1 ,
0, "offset", 10, CSYS_IRATE, CSYS_NORMAL, 1 ,
1, "mean", 11, CSYS_IRATE, CSYS_NORMAL, 1 ,
1, "std", 12, CSYS_IRATE, CSYS_NORMAL, 1 ,
0, "f", 13, CSYS_KRATE, CSYS_NORMAL, 1 ,
0, "bright", 14, CSYS_KRATE, CSYS_NORMAL, 1 ,
0, "volume", 15, CSYS_KRATE, CSYS_NORMAL, 1 ,
1, "attack", 16, CSYS_IRATE, CSYS_NORMAL, 1 ,
1, "release", 17, CSYS_IRATE, CSYS_NORMAL, 1 ,
1, "attlim", 18, CSYS_IRATE, CSYS_NORMAL, 1 ,
0, "incr", 19, CSYS_KRATE, CSYS_NORMAL, 1 ,
0, "rel", 20, CSYS_KRATE, CSYS_NORMAL, 1 ,
0, "tot", 21, CSYS_KRATE, CSYS_NORMAL, 1 ,
0, "mod", 22, CSYS_KRATE, CSYS_NORMAL, 1 ,
0, "y", 23, CSYS_ARATE, CSYS_NORMAL, 1 ,
0, "fsmooth", 24, CSYS_ARATE, CSYS_NORMAL, 1 ,
0, "init", 25, CSYS_ARATE, CSYS_NORMAL, 1 ,
0, "env", 26, CSYS_ARATE, CSYS_NORMAL, 1  };

#define CSYS_mix_VARNUM 0

csys_varstruct csys_mix_vars[1];

csys_instrstruct csys_instr[CSYS_INSTRNUM] = {
0, "linbuzz",2, CSYS_linbuzz_VARNUM, &(csys_linbuzz_vars[0]),1, 0 ,
1, "mix",0, CSYS_mix_VARNUM, &(csys_mix_vars[0]),1, 1 };

struct instr_line cm_linbuzz[MAXCNOTES];
struct instr_line * cm_linbuzz___first = &cm_linbuzz[1];
struct instr_line * cm_linbuzz___last = &cm_linbuzz[0];
struct instr_line * cm_linbuzz___end = &cm_linbuzz[MAXCNOTES-1];
struct instr_line * cm_linbuzz___next = NULL;

struct instr_line e_mix[1];

#define CSYS_CCPOS 0
#define CSYS_TOUCHPOS 128
#define CSYS_CHTOUCHPOS 256
#define CSYS_BENDPOS 257
#define CSYS_EXTPOS 258
#define CSYS_FRAMELEN 259
#define CSYS_MAXPRESETS 1

#define CSYS_NULLPROGRAM 0

struct instr_line **cmp_first[CSYS_MAXPRESETS] = {
&cm_linbuzz___first};

struct instr_line **cmp_last[CSYS_MAXPRESETS] = {
&cm_linbuzz___last};

struct instr_line **cmp_end[CSYS_MAXPRESETS] = {
&cm_linbuzz___end};

struct instr_line **cmp_next[CSYS_MAXPRESETS] = {
&cm_linbuzz___next};

#define CSYS_MAXEXTCHAN 16

struct instr_line **cme_first[CSYS_MAXEXTCHAN] = {
&cm_linbuzz___first,&cm_linbuzz___first,&cm_linbuzz___first,&cm_linbuzz___first,&cm_linbuzz___first,
&cm_linbuzz___first,&cm_linbuzz___first,&cm_linbuzz___first,&cm_linbuzz___first,&cm_linbuzz___first,
&cm_linbuzz___first,&cm_linbuzz___first,&cm_linbuzz___first,&cm_linbuzz___first,&cm_linbuzz___first,
&cm_linbuzz___first};

struct instr_line **cme_last[CSYS_MAXEXTCHAN] = {
&cm_linbuzz___last,&cm_linbuzz___last,&cm_linbuzz___last,&cm_linbuzz___last,&cm_linbuzz___last,
&cm_linbuzz___last,&cm_linbuzz___last,&cm_linbuzz___last,&cm_linbuzz___last,&cm_linbuzz___last,
&cm_linbuzz___last,&cm_linbuzz___last,&cm_linbuzz___last,&cm_linbuzz___last,&cm_linbuzz___last,
&cm_linbuzz___last};

struct instr_line **cme_end[CSYS_MAXEXTCHAN] = {
&cm_linbuzz___end,&cm_linbuzz___end,&cm_linbuzz___end,&cm_linbuzz___end,&cm_linbuzz___end,
&cm_linbuzz___end,&cm_linbuzz___end,&cm_linbuzz___end,&cm_linbuzz___end,&cm_linbuzz___end,
&cm_linbuzz___end,&cm_linbuzz___end,&cm_linbuzz___end,&cm_linbuzz___end,&cm_linbuzz___end,
&cm_linbuzz___end};

struct instr_line **cme_next[CSYS_MAXEXTCHAN] = {
&cm_linbuzz___next,&cm_linbuzz___next,&cm_linbuzz___next,&cm_linbuzz___next,&cm_linbuzz___next,
&cm_linbuzz___next,&cm_linbuzz___next,&cm_linbuzz___next,&cm_linbuzz___next,&cm_linbuzz___next,
&cm_linbuzz___next,&cm_linbuzz___next,&cm_linbuzz___next,&cm_linbuzz___next,&cm_linbuzz___next,
&cm_linbuzz___next};

int cme_preset[CSYS_MAXEXTCHAN] = {
0,CSYS_MAXPRESETS,CSYS_MAXPRESETS,CSYS_MAXPRESETS,CSYS_MAXPRESETS,
CSYS_MAXPRESETS,CSYS_MAXPRESETS,CSYS_MAXPRESETS,CSYS_MAXPRESETS,CSYS_MAXPRESETS,
CSYS_MAXPRESETS,CSYS_MAXPRESETS,CSYS_MAXPRESETS,CSYS_MAXPRESETS,CSYS_MAXPRESETS,
CSYS_MAXPRESETS};

int csys_bank = 0;
int csys_banklsb = 0;
int csys_bankmsb = 0;

#define MAXLINES 256
#define MAXSTATE 264


#define MAXVARSTATE 94
#define MAXTABLESTATE 1

/* ninstr: used for score, effects, */
/* and dynamic instruments          */

struct ninstr_types {

struct instr_line * iline; /* pointer to score line */
dstack v[MAXVARSTATE];     /* parameters & variables*/
struct tableinfo t[MAXTABLESTATE]; /* tables */

} ninstr[MAXSTATE];

#define CSYS_CDRIVER_LINMIDI
#define ASYS_OUTDRIVER_LINUX
#define ASYS_HASOUTPUT
#define ASYS_KSYNC


/*
#    Sfront, a SAOL to C translator    
#    This file: merged linux/freebsd audio driver for sfront
#    Copyright (C) 1999  Regents of the University of California
#    Copyright (C) 2000  Bertrand Petit
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License (Version 2) as
#    published by the Free Software Foundation.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#    Maintainer: John Lazzaro, lazzaro@cs.berkeley.edu
*/

#define ASYSIO_LINUX   0
#define ASYSIO_FREEBSD 1

#define ASYSIO_OSTYPE  ASYSIO_LINUX

/****************************************************************/
/****************************************************************/
/*                linux audio driver for sfront                 */ 
/****************************************************************/

/**************************************************/
/* define flags for fifo mode, and for a timer to */
/* catch SAOL infinite loops                      */
/**************************************************/

#if (defined(ASYS_HASOUTPUT) && (ASYSIO_OSTYPE == ASYSIO_LINUX) && \
     defined(CSYS_CDRIVER_LINMIDI) && (ASYS_TIMEOPTION == ASYS_TIMESYNC) && \
     !defined(ASYS_HASINPUT))
#define ASYSIO_USEFIFO 1
#endif

#if (defined(ASYS_HASOUTPUT) && (ASYSIO_OSTYPE == ASYSIO_LINUX) && \
    (ASYS_TIMEOPTION != ASYS_TIMESYNC))
#define ASYSIO_USEFIFO 1
#endif

#ifndef ASYSIO_USEFIFO
#define ASYSIO_USEFIFO 0
#endif

/**************************************************/
/* include headers, based on flags set above      */
/**************************************************/

#include <unistd.h>
#include <sys/ioctl.h>
#include <fcntl.h>

#if (ASYSIO_OSTYPE == ASYSIO_LINUX)
#include <sys/soundcard.h>
#include <endian.h>
#endif

#if (ASYSIO_OSTYPE == ASYSIO_FREEBSD)
#include <machine/soundcard.h>
#include <machine/endian.h>
#endif

#include <signal.h>  
#include <sys/time.h>  

#if ASYSIO_USEFIFO
#include <sched.h>  
#if (ASYS_TIMEOPTION == ASYS_TIMESYNC)
#include <time.h>
#endif
#endif

/******************************/
/* other constant definitions */
/******************************/

#ifndef ASYSIO_DSPDEV
#define ASYSIO_DSPDEV "/dev/dsp"
#endif

/* determines native audio format */

#if (BYTE_ORDER == BIG_ENDIAN)
# define ASYSIO_AFORMAT AFMT_S16_BE
#else
# if (BYTE_ORDER == LITTLE_ENDIAN)
#  define ASYSIO_AFORMAT AFMT_S16_LE
# else
#  error "BYTE_ORDER not defined?"
# endif
#endif

/* codes for IO types */

#define ASYSIO_I  0
#define ASYSIO_O  1
#define ASYSIO_IO 2

/* minimum fragment size */

#define ASYSIO_FRAGMIN    16
#define ASYSIO_LOGFRAGMIN 4

/* number of silence buffers */

#define ASYSO_LNUMBUFF 4

/* maximum number of I/O retries before termination */

#define ASYSIO_MAXRETRY 256

#if ASYSIO_USEFIFO                      /* SCHED_FIFO constants for ksync()  */

#if (ASYS_TIMEOPTION == ASYS_TIMESYNC)
#define ASYSIO_SYNC_TIMEOUT    5        /* idle time to leave SCHED_FIFO     */
#define ASYSIO_SYNC_ACTIVE     0        /* machine states for noteon timeout */
#define ASYSIO_SYNC_WAITING    1
#define ASYSIO_SYNC_SCHEDOTHER 2
#else
#define ASYSIO_MAXBLOCK ((int)KRATE)*2  /* max wait tor let SCHED_OTHERs run */
#endif

#endif

/************************/
/* variable definitions */
/************************/

int  asysio_fd;                    /* device pointer */
long asysio_srate;                 /* sampling rate */
long asysio_channels;              /* number of channels */
long asysio_size;                  /* # samples in a buffer */
long asysio_bsize;                 /* actual # bytes in a buffer */            
long asysio_requested_bsize;       /* requested # bytes in a buffer */        
long asysio_input;                 /* 1 if ASYSIO */
long asysio_blocktime;             /* time (in bytes) blocked in kcycle */

struct count_info asysio_ptr;      /* for GET{I,O}*PTR  ioctl calls */
struct audio_buf_info asysio_info; /* for GET{I,O}SPACE ioctl calls */

#if defined(ASYS_HASOUTPUT)
short * asyso_buf = NULL;          /* output buffer */
int asysio_puts;                   /* total number of putbufs */
int asysio_reset;                  /* flags an overrun */
#endif

#if defined(ASYS_HASINPUT)
short * asysi_buf = NULL;          /* input buffer */
struct audio_buf_info asysi_info;  /* input dma status */
#endif

sigset_t asysio_iloop_mask;            /* for masking off iloop interrupt */
struct sigaction asysio_iloop_action;  /* for setting up iloop interrupt  */
struct itimerval asysio_iloop_timer;   /* for setting up iloop timer      */

#if ASYSIO_USEFIFO 
int asysio_fifo;                       /* can get into sched_fifo mode */
struct sched_param asysio_fifoparam;   /* param block for fifo mode */
struct sched_param asysio_otherparam;  /* param block for other mode */

#if (ASYS_TIMEOPTION == ASYS_TIMESYNC)

/* state machine variables for noteon timeout */
int    asysio_sync_state;
time_t asysio_sync_waitstart;
extern int csysi_newnote;       /* from linmidi */

#else

/* state to detect long periods w/o blocking */
int asysio_sync_noblock;                /* how many acycles since last block */
struct timespec asysio_sync_sleeptime;  /* time to wait during forced block  */

#endif

#endif

#if defined(ASYS_KSYNC)                      /* ksync() state */
struct count_info asysio_sync_ptr;           
int asysio_sync_target, asysio_sync_incr;    
float asysio_sync_cpuscale;                  
#endif

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                      shutdown routines                       */
/*______________________________________________________________*/


/****************************************************************/
/*                    shuts down soundcard                      */
/****************************************************************/

void asysio_shutdown(void)

{
  if (ioctl(asysio_fd, SNDCTL_DSP_SYNC, 0) == -1)
    {
      fprintf(stderr, "\nSoundcard Error: SNDCTL_DSP_SYNC Ioctl Problem\n");
      fprintf(stderr, "Errno Message: %s\n\n", strerror(errno));
    }
  close(asysio_fd);

  /* so that a slow exit doesn't trigger timer */

  asysio_iloop_timer.it_value.tv_sec = 0;
  asysio_iloop_timer.it_value.tv_usec = 0;
  asysio_iloop_timer.it_interval.tv_sec = 0;
  asysio_iloop_timer.it_interval.tv_usec = 0;
  
  if (setitimer(ITIMER_PROF, &asysio_iloop_timer, NULL) < 0)
    {
      fprintf(stderr, "\nSoundcard Driver Error:\n\n");
      fprintf(stderr, "  Couldn't set up ITIMER_PROF timer.\n");
      fprintf(stderr, "  Errno Message: %s\n\n", strerror(errno));
    }
}


#if (defined(ASYS_HASOUTPUT)&&(!defined(ASYS_HASINPUT)))

/****************************************************************/
/*                    shuts down audio output                   */
/****************************************************************/

void asys_oshutdown(void)

{
  asysio_shutdown();
  if (asyso_buf != NULL)
    free(asyso_buf);
}

#endif

#if (!defined(ASYS_HASOUTPUT)&&(defined(ASYS_HASINPUT)))

/****************************************************************/
/*                    shuts down audio input                    */
/****************************************************************/

void asys_ishutdown(void)

{
  asysio_shutdown();  
  if (asysi_buf != NULL)
    free(asysi_buf);
}

#endif


#if (defined(ASYS_HASOUTPUT)&&(defined(ASYS_HASINPUT)))

/****************************************************************/
/*              shuts down audio input and output               */
/****************************************************************/

void asys_ioshutdown(void)

{
  asysio_shutdown();
  if (asyso_buf != NULL)
    free(asyso_buf);
  if (asysi_buf != NULL)
    free(asysi_buf);
}

#endif


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                 initialization routines                      */
/*______________________________________________________________*/


/****************************************************************/
/*          generic error-checking ioctl wrapper                */
/****************************************************************/

#define ASYSIO_IOCTL_CALL(x,y,z)  do { if (ioctl(x,y,z) == -1){\
      fprintf(stderr, "  Error: %s Ioctl Problem\n", #y ); \
      fprintf(stderr, "  Errno Message: %s\n\n", strerror(errno));\
      close(asysio_fd); return ASYS_ERROR;}} while (0)

#define  ASYSIO_ERROR_RETURN(x) do {\
      fprintf(stderr, "  Error: %s.\n", x);\
      fprintf(stderr, "  Errno Message: %s\n\n", strerror(errno));\
      close(asysio_fd);\
      return ASYS_ERROR; } while (0)

#define  ASYSIO_ERROR_RETURN_NOERRNO(x) do {\
      fprintf(stderr, "  Error: %s.\n", x);\
      close(asysio_fd);\
      return ASYS_ERROR; } while (0)


/****************************************************************/
/*               opens the soudcard device                      */
/****************************************************************/

int asysio_opendevice(int dir, int toption)

{

  switch(dir) {
  case ASYSIO_I:
    asysio_fd = open(ASYSIO_DSPDEV, O_RDONLY, 0);
    asysio_input = 1;
    break;
  case ASYSIO_O:
    asysio_fd = open(ASYSIO_DSPDEV, O_WRONLY, 0);
    asysio_input = 0;
    break;
  case ASYSIO_IO:
    asysio_fd = open(ASYSIO_DSPDEV, O_RDWR, 0);
    asysio_input = 1;
    break;
  default:
    fprintf(stderr, "  Error: Unexpected dir parameter value in \n");
    fprintf(stderr, "         asysio_setup.\n\n");
    return ASYS_ERROR;
  }

  if (asysio_fd == -1)
    {
      fprintf(stderr, "  Error: Can't open device %s (%s)\n\n", ASYSIO_DSPDEV,
	      strerror(errno));
      return ASYS_ERROR;
    }
  return ASYS_DONE;

}

/****************************************************************/
/*         signal handler for trapping SAOL infinite loops      */
/****************************************************************/

void asysio_iloop_handler(int signum) 
{   
  fprintf(stderr, "  Error: Either\n\n");
  fprintf(stderr, "    [1] The SAOL program has an infinite loop in it, or\n");
  fprintf(stderr, "    [2] Content is too complex for real-time work.\n\n");
  fprintf(stderr, "  Exiting program ...\n\n");
  exit(0);
}


/****************************************************************/
/*         initializes iloop (heartbeat) interrupt              */
/****************************************************************/

int asysio_initiloop(void)

{

  /*********************************************************/
  /* set up signal handler for infinite-loop (iloop) timer */
  /*********************************************************/
  
  if (sigemptyset(&asysio_iloop_action.sa_mask) < 0)
    ASYSIO_ERROR_RETURN("Couldn't run sigemptyset(iloop) OS call");

  /* infinite-loop timer wins over midi overrun timer */

  if (sigaddset(&asysio_iloop_action.sa_mask, SIGALRM) < 0)
    ASYSIO_ERROR_RETURN("Couldn't run sigaddset(iloop) OS call");

  asysio_iloop_action.sa_flags = SA_RESTART;
  asysio_iloop_action.sa_handler = asysio_iloop_handler;
  
  if (sigaction(SIGPROF, &asysio_iloop_action, NULL) < 0)
    ASYSIO_ERROR_RETURN("Couldn't set up SIGPROF signal handler");


  /************************/
  /* set up timer and arm */
  /************************/

  asysio_iloop_timer.it_value.tv_sec = 3;
  asysio_iloop_timer.it_value.tv_usec = 0;
  asysio_iloop_timer.it_interval.tv_sec = 0;
  asysio_iloop_timer.it_interval.tv_usec = 0;

  if (setitimer(ITIMER_PROF, &asysio_iloop_timer, NULL) < 0)
    ASYSIO_ERROR_RETURN("Couldn't set up ITIMER_PROF timer");

  return ASYS_DONE;
}

/****************************************************************/
/*                 initializes sched_fifo                       */
/****************************************************************/

int asysio_initscheduler(void)

{

#if ASYSIO_USEFIFO

  /*******************************/
  /* set up sched_fifo variables */
  /*******************************/

  memset(&asysio_otherparam, 0, sizeof(struct sched_param));
  memset(&asysio_fifoparam, 0, sizeof(struct sched_param));
 
  if ((asysio_fifoparam.sched_priority =
       sched_get_priority_max(SCHED_FIFO)) < 0)
    ASYSIO_ERROR_RETURN("Couldn't get scheduling priority");

  asysio_fifoparam.sched_priority--;

  /********************************/
  /* try to enter sched-fifo mode */
  /********************************/

  asysio_fifo = !sched_setscheduler(0, SCHED_FIFO, &asysio_fifoparam);

#endif

  return ASYS_DONE;
}

/****************************************************************/
/*                 prints startup screen                        */
/****************************************************************/

int asysio_screenwriter(void)

{
  int i, found;
  int haslinmidi = 0;
  float actual_latency;


  fprintf(stderr, "%s ",  (ASYS_LATENCYTYPE == ASYS_HIGHLATENCY)? 
	  "Streaming" : "Interactive");

  fprintf(stderr, "%s Audio ", (asysio_channels == 2) ? "Stereo" : "Mono");

#if defined(ASYS_HASOUTPUT)
  fprintf(stderr, "%s", asysio_input ? "Input/Output" : "Output");
#else
  fprintf(stderr, "Input");
#endif

  found = i = 0;
  while (i < csys_sfront_argc)
    {
      if (!(strcmp(csys_sfront_argv[i],"-bitc") && 
	    strcmp(csys_sfront_argv[i],"-bit") &&
	    strcmp(csys_sfront_argv[i],"-orc")))
	{
	  i++;
	  fprintf(stderr, " for %s", csys_sfront_argv[i]);
	  found = 1;
	  break;
	}
      i++;
    }
  if (!found)
    fprintf(stderr, " for UNKNOWN");


  i = 0;
  while (i < csys_sfront_argc)
    {
      if (!strcmp(csys_sfront_argv[i],"-cin"))
	{
	  i++;
	  fprintf(stderr, " (-cin %s)", csys_sfront_argv[i]);
	  break;
	}
      i++;
    }
  fprintf(stderr, "\n\n");


#if defined(CSYS_CDRIVER_LINMIDI)

  haslinmidi = 1;

#endif

#if (defined(CSYS_CDRIVER_LINMIDI) || defined(CSYS_CDRIVER_ALSAMIDI)\
      || defined(CSYS_CDRIVER_ALSASEQ) || defined(CSYS_CDRIVER_ASCII))

  /* list midi presets available */

  fprintf(stderr, 
	  "MIDI Preset Numbers (use MIDI controller to select):\n\n");

  for (i = 0; i < CSYS_PRESETNUM; i++)
    {
      fprintf(stderr, "%3i. %s", 
	      csys_presets[i].preset,
	      csys_instr[csys_presets[i].index].name);
      if ((i&1))
	fprintf(stderr, "\n");
      else
	{
	  fprintf(stderr, "\t\t");
	  if (i == (CSYS_PRESETNUM-1))
	    fprintf(stderr, "\n");
	}
    }
  fprintf(stderr, "\n");

#endif

#if defined(CSYS_CDRIVER_ASCII)

  fprintf(stderr, 
  "To play tunes on ASCII keyboard: a-z for notes, 0-9 for MIDI presets,\n");
  fprintf(stderr, 
  "cntrl-C exits. If autorepeat interferes, exit and run 'xset -r' (in X).\n\n");
  
#endif

  /* diagnose best flags to use, and if they are used */

#ifdef ASYS_HASOUTPUT

  if ((ASYS_LATENCYTYPE == ASYS_HIGHLATENCY) || asysio_input ||
      (!haslinmidi))
    {
      if (geteuid() || (ASYS_TIMEOPTION == ASYS_TIMESYNC))
	{
	  fprintf(stderr, "For best results, make these changes:\n"); 
	  fprintf(stderr, "\n");
	  if (ASYS_TIMEOPTION == ASYS_TIMESYNC)
	    fprintf(stderr, "   * Remove sfront -timesync flag\n");
	  if (geteuid())
	    fprintf(stderr, "   * Run sa.c executable as root.\n");
	  fprintf(stderr, "\n");
	}
    }
  else
    {
      fprintf(stderr, "This application runs best as root (%s), with:\n",
	      !geteuid() ? "which you are": "which you aren't"); 
      fprintf(stderr, "\n");
      fprintf(stderr, "  [1] Sfront -playback flag. Good audio quality, keeps\n");
      fprintf(stderr, "      the mouse/kbd alive");
      fprintf(stderr, "%s.\n", (ASYS_TIMEOPTION == ASYS_PLAYBACK) ?
	      " (currently chosen)":"");
      fprintf(stderr, "  [2] Sfront -timesync flag. Better quality, console\n");
      fprintf(stderr, "      freezes during MIDI input");
      fprintf(stderr, "%s.\n", (ASYS_TIMEOPTION == ASYS_TIMESYNC) ?
	      " (currently chosen)":"");
      fprintf(stderr, "\n");
    }

#endif

  /* latency information */

#if (defined(ASYS_HASOUTPUT))

  ASYSIO_IOCTL_CALL(asysio_fd, SNDCTL_DSP_GETOSPACE, &asysio_info);

  fprintf(stderr, "If audio artifacts still occur, try");
  
  actual_latency = ATIME*ASYSO_LNUMBUFF*(asysio_size >> (asysio_channels - 1));
  
  if (asysio_info.fragstotal < ASYSO_LNUMBUFF)
    {
      fprintf(stderr, " sfront -latency %f flag, and see\n", 
	      0.5F*actual_latency);
    }
  else
    {
      fprintf(stderr, " sfront -latency %f flag, and see\n", 
	      2.0F*actual_latency);

    }
  if (ASYS_LATENCYTYPE == ASYS_LOWLATENCY)
    fprintf(stderr, "http://www.cs.berkeley.edu/"
	    "~lazzaro/sa/sfman/user/use/index.html#interact\n") ;
  else
    fprintf(stderr, "http://www.cs.berkeley.edu/"
	    "~lazzaro/sa/sfman/user/use/index.html#stream\n") ;

  fprintf(stderr, "\n");

  if ((asysio_bsize != ASYSIO_FRAGMIN) &&
      (asysio_bsize == asysio_requested_bsize) && 
      (ASYS_LATENCYTYPE == ASYS_LOWLATENCY))
  {
    fprintf(stderr, "If interactive response is slow, try ");
    fprintf(stderr, "sfront -latency %f flag.\n", 0.5F*actual_latency);
    fprintf(stderr, "\n");
  }

#endif

  fprintf(stderr, 
  "USE AT YOUR OWN RISK. Running as root may damage your file system,\n");
  fprintf(stderr, 
  "and network use may result in a malicious attack on your machine.\n\n");

#if (ASYSIO_USEFIFO && (ASYS_TIMEOPTION == ASYS_TIMESYNC))

  if (!geteuid())
    {
      fprintf(stderr, 
      "NOTE: Mouse and keyboard are frozen for %i seconds after a MIDI\n",
	      ASYSIO_SYNC_TIMEOUT);
      fprintf(stderr, 
	      "NoteOn or NoteOff is received. Do not be alarmed.\n");
    }

#endif

  if (NSYS_NET)
    fprintf(stderr, "Network status: Contacting SIP server\n");

  return ASYS_DONE;

}


/****************************************************************/
/*        setup operations common to input and output           */
/****************************************************************/

int asysio_setup(long srate, long channels, int dir, int toption)

{
  long i, j, maxfrag;

  /******************/
  /* open soundcard */
  /******************/

  if (asysio_opendevice(dir, toption) == ASYS_ERROR)
    return ASYS_ERROR;
  
  /**************************************/
  /* set up bidirectional I/O if needed */
  /**************************************/

  if (dir == ASYSIO_IO)
    {

#if (ASYSIO_OSTYPE != ASYSIO_FREEBSD)

      ASYSIO_IOCTL_CALL(asysio_fd, SNDCTL_DSP_SETDUPLEX, 0);

#endif 

      ASYSIO_IOCTL_CALL(asysio_fd, SNDCTL_DSP_GETCAPS, &j);

      if (!(j & DSP_CAP_DUPLEX))
	ASYSIO_ERROR_RETURN_NOERRNO("Sound card can't do bidirectional audio");
    }

  /************************/
  /* range check channels */
  /************************/

  if (channels > 2)
    ASYSIO_ERROR_RETURN_NOERRNO("Sound card can't handle > 2 channels");

  /*********************/
  /* set fragment size */
  /*********************/

  j = ASYSIO_LOGFRAGMIN;
  i = ASYSIO_FRAGMIN >> channels;   /* only works for channels = 1, 2 */

  /* find closest power-of-two fragment size to latency request */

  while (2*ATIME*i*ASYSO_LNUMBUFF < ASYS_LATENCY)
    {
      i <<= 1;
      j++;
    }
  if ((ATIME*2*i*ASYSO_LNUMBUFF - ASYS_LATENCY) < 
      (ASYS_LATENCY - ATIME*i*ASYSO_LNUMBUFF))
    {
      i <<= 1;
      j++;
    }

  asysio_requested_bsize = 2*i*channels;

  maxfrag = (ASYS_TIMEOPTION != ASYS_TIMESYNC) ? ASYSO_LNUMBUFF :
             ASYSO_LNUMBUFF + ((ACYCLE/i) + 1);

  j |= (maxfrag << 16);
  ASYSIO_IOCTL_CALL(asysio_fd, SNDCTL_DSP_SETFRAGMENT, &j);

  /********************/
  /* set audio format */
  /********************/

  j = ASYSIO_AFORMAT;
  ASYSIO_IOCTL_CALL(asysio_fd, SNDCTL_DSP_SETFMT, &j);

  if (j != ASYSIO_AFORMAT)
    ASYSIO_ERROR_RETURN_NOERRNO("Soundcard can't handle native shorts");

  /****************************************************/
  /* set number of channels -- later add channels > 2 */
  /****************************************************/

  asysio_channels = channels--;
  ASYSIO_IOCTL_CALL(asysio_fd, SNDCTL_DSP_STEREO, &channels);

  if (channels != (asysio_channels-1))
    ASYSIO_ERROR_RETURN_NOERRNO("Soundcard can't handle number of channels");

  /*********************/
  /* set sampling rate */
  /*********************/

  asysio_srate = srate;
  ASYSIO_IOCTL_CALL(asysio_fd, SNDCTL_DSP_SPEED, &srate);

  if (abs(asysio_srate - srate) > 1000)
    ASYSIO_ERROR_RETURN_NOERRNO("Soundcard can't handle sampling rate");

  /******************************/
  /* compute actual buffer size */
  /******************************/

  ASYSIO_IOCTL_CALL(asysio_fd, SNDCTL_DSP_GETBLKSIZE, &asysio_bsize);
  asysio_size = asysio_bsize >> 1;

  /*************************/
  /* print out info screen */
  /*************************/

  if (asysio_screenwriter() == ASYS_ERROR)
    return ASYS_ERROR;

  /*********************************/
  /* set SCHED_FIFO if appropriate */
  /*********************************/

  if (asysio_initscheduler() == ASYS_ERROR)
    return ASYS_ERROR;

  /**********************************/
  /* set up iloop (heartbeat) timer */
  /**********************************/

  if (asysio_initiloop() == ASYS_ERROR)
    return ASYS_ERROR;

  return ASYS_DONE;
}



#if (defined(ASYS_HASOUTPUT) && !defined(ASYS_HASINPUT))

/****************************************************************/
/*        sets up audio output for a given srate/channels       */
/****************************************************************/

int asys_osetup(long srate, long ochannels, long osample, 
                char * oname, long toption)

{
  if (asysio_setup(srate, ochannels, ASYSIO_O, toption) == ASYS_ERROR)
    return ASYS_ERROR;

  if (!(asyso_buf = (short *)calloc(asysio_size, sizeof(short))))
    ASYSIO_ERROR_RETURN("Can't allocate output buffer");

  return ASYS_DONE;
}

#endif


#if (!defined(ASYS_HASOUTPUT) && defined(ASYS_HASINPUT))

/****************************************************************/
/*        sets up audio input for a given srate/channels       */
/****************************************************************/

int asys_isetup(long srate, long ichannels, long isample, 
                char * iname, long toption)

{
  if (asysio_setup(srate, ichannels, ASYSIO_I, toption) == ASYS_ERROR)
    return ASYS_ERROR;
  if (!(asysi_buf = (short *)malloc(asysio_bsize)))
    ASYSIO_ERROR_RETURN("Can't allocate input buffer");

  return ASYS_DONE;
}

#endif


#if (defined(ASYS_HASOUTPUT) && defined(ASYS_HASINPUT))

/****************************************************************/
/*   sets up audio input and output for a given srate/channels  */
/****************************************************************/

int asys_iosetup(long srate, long ichannels, long ochannels,
                 long isample, long osample, 
                 char * iname, char * oname, long toption)


{

  if (ichannels != ochannels)
    ASYSIO_ERROR_RETURN_NOERRNO
      ("Soundcard needs SAOL inchannels == outchannels");

  if (asysio_setup(srate, ichannels, ASYSIO_IO, toption) == ASYS_ERROR)
    return ASYS_ERROR;

  if (!(asysi_buf = (short *)malloc(asysio_bsize)))
    ASYSIO_ERROR_RETURN("Can't allocate input buffer");

  if (!(asyso_buf = (short *)calloc(asysio_size, sizeof(short))))
    ASYSIO_ERROR_RETURN("Can't allocate output buffer");

  return ASYS_DONE;
}

#endif


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*            input, output, and recovery routines              */
/*______________________________________________________________*/


#if defined(ASYS_HASINPUT)

/****************************************************************/
/*               gets one frame of audio from input             */
/****************************************************************/

int asys_getbuf(ASYS_ITYPE * asys_ibuf[], long * isize)

{
  long diffcompute, starttime;
  long size, recv, bptr, retry;

  *isize = asysio_size;

  if (*asys_ibuf == NULL)
    *asys_ibuf = asysi_buf;

  ASYSIO_IOCTL_CALL(asysio_fd, SNDCTL_DSP_GETISPACE, &asysio_info);

#if defined(ASYS_HASOUTPUT)

  if (diffcompute = (asysio_info.bytes < asysio_bsize))
    {  
      ASYSIO_IOCTL_CALL(asysio_fd, SNDCTL_DSP_GETOPTR, &asysio_ptr);
      starttime = asysio_ptr.bytes;
    }

#endif

  retry = bptr = 0;
  size = asysio_bsize;

  while ((recv = read(asysio_fd, &((*asys_ibuf)[bptr]), size)) != size)
    {      
      if (++retry > ASYSIO_MAXRETRY)
	ASYSIO_ERROR_RETURN("Too many I/O retries -- asys_getbuf");

      if (recv < 0)  /* errors */
	{
	  if ((errno == EAGAIN) || (errno == EINTR))
	    continue;   
	  else
	    ASYSIO_ERROR_RETURN("Read error on output audio device");
	}
      else
	{
	  bptr += recv; /* partial read */
	  size -= recv;
	}
    }

#if defined(ASYS_HASOUTPUT)

  if (diffcompute)
    {  
      ASYSIO_IOCTL_CALL(asysio_fd, SNDCTL_DSP_GETOPTR, &asysio_ptr);
      asysio_blocktime += (asysio_ptr.bytes - starttime);
    }

#endif

  return ASYS_DONE;
}

#endif


#if defined(ASYS_HASOUTPUT)

/****************************************************************/
/*               sends one frame of audio to output             */
/****************************************************************/

int asys_putbuf(ASYS_OTYPE * asys_obuf[], long * osize)


{
  long size, sent, bptr, retry;
  long diffcompute, starttime;

  size = (*osize)*2;


  if (asysio_reset)
    return ASYS_DONE;

  ASYSIO_IOCTL_CALL(asysio_fd, SNDCTL_DSP_GETOSPACE, &asysio_info);

  asysio_reset = (++asysio_puts > ASYSO_LNUMBUFF) && 
    (asysio_info.fragments == asysio_info.fragstotal);
  if (asysio_reset)
    return ASYS_DONE;

#if (ASYS_TIMEOPTION != ASYS_TIMESYNC)

  if (diffcompute = (asysio_info.bytes < size))
    {  
      ASYSIO_IOCTL_CALL(asysio_fd, SNDCTL_DSP_GETOPTR, &asysio_ptr);
      starttime = asysio_ptr.bytes;
    }

#endif

  retry = bptr = 0;
  while ((sent = write(asysio_fd, &((*asys_obuf)[bptr]), size)) != size)
    {
      if (++retry > ASYSIO_MAXRETRY)
	ASYSIO_ERROR_RETURN("Too many I/O retries -- asys_putbuf");

      if (sent < 0)  /* errors */
	{
	  if ((errno == EAGAIN) || (errno == EINTR))
	    continue;   
	  else
	    ASYSIO_ERROR_RETURN("Write error on output audio device");
	}
      else
	{
	  bptr += sent;  /* partial write */
	  size -= sent;
	}
    }

#if (ASYS_TIMEOPTION != ASYS_TIMESYNC)

  if (diffcompute)
    {  
      ASYSIO_IOCTL_CALL(asysio_fd, SNDCTL_DSP_GETOPTR, &asysio_ptr);
      asysio_blocktime += (asysio_ptr.bytes - starttime);
    }

#endif

  *osize = asysio_size;
  return ASYS_DONE;
}


/****************************************************************/
/*        creates buffer, and generates starting silence        */
/****************************************************************/

int asys_preamble(ASYS_OTYPE * asys_obuf[], long * osize)

{
  int i;

  *asys_obuf = asyso_buf;
  *osize = asysio_size;

  for(i = 0; i < ASYSO_LNUMBUFF; i++)
    if (asys_putbuf(asys_obuf, osize) == ASYS_ERROR)
      return ASYS_ERROR;

  return ASYS_DONE;
}


/****************************************************************/
/*               recovers from an overrun                       */
/****************************************************************/

int asysio_recover(void)

{
  long size, recv, bptr, retry;
  int i;

  asysio_reset = 0;

  memset(asyso_buf, 0, asysio_bsize);

  /*************************/
  /* flush input if needed */
  /*************************/

#if defined(ASYS_HASINPUT)

  ASYSIO_IOCTL_CALL(asysio_fd, SNDCTL_DSP_GETISPACE, &asysi_info);
  
  while (asysi_info.fragments > 0)
    {
      retry = bptr = 0;
      size = asysio_bsize;

      while ((recv = read(asysio_fd, &(asysi_buf[bptr]), size)) != size)
	{      
	  if (++retry > ASYSIO_MAXRETRY)
	    ASYSIO_ERROR_RETURN("Too many I/O retries -- asysio_recover");

	  if (recv < 0)  /* errors */
	    {
	      if ((errno == EAGAIN) || (errno == EINTR))
		continue;   
	      else
		ASYSIO_ERROR_RETURN("Read error on output audio device");
	    }
	  else
	    {
	      bptr += recv; /* partial read */
	      size -= recv;
	    }
	}

      ASYSIO_IOCTL_CALL(asysio_fd, SNDCTL_DSP_GETISPACE, &asysi_info);
    }

  ibusidx = 0;
  if (asys_getbuf(&asys_ibuf, &asys_isize)==ASYS_ERROR)
    return ASYS_ERROR;

#endif

  /**************************************/
  /* fill latency interval with silence */ 
  /**************************************/

  asysio_puts = 0;
  for(i = 0; i < ASYSO_LNUMBUFF; i++)
    if (asys_putbuf(&asyso_buf, &asysio_size) == ASYS_ERROR)
      return ASYS_ERROR;

  return ASYS_DONE;

}


#endif


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*        ksync() system for time synchronization          */ 
/*_________________________________________________________*/

#if defined(ASYS_KSYNC)

/***********************************************************/
/*         initializes k-rate boundaries sync              */
/***********************************************************/

void ksyncinit()

{
  asysio_sync_target = asysio_sync_incr = ACYCLE*asysio_channels*2;  
  asysio_sync_cpuscale = 1.0F/asysio_sync_incr;

  /* for -timesync, set up SCHED_FIFO watchdog state machine */

#if (ASYSIO_USEFIFO && (ASYS_TIMEOPTION == ASYS_TIMESYNC))

  if (asysio_fifo)

    {
      asysio_sync_state = ASYSIO_SYNC_SCHEDOTHER;
      if (sched_setscheduler(0, SCHED_OTHER, &asysio_otherparam))
	epr(0,NULL,NULL,"internal error -- sched_other unavailable");
    }

#endif

  /* elsewise, set up SCHED_FIFO monitor to force blocking */

#if (ASYSIO_USEFIFO && (ASYS_TIMEOPTION != ASYS_TIMESYNC))

  asysio_sync_noblock = 0;
  asysio_sync_sleeptime.tv_sec = 0;
  asysio_sync_sleeptime.tv_nsec = 2000001;  /* 2ms + epsilon forces block */
 
#endif

}


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*     different ksync()s for -timesync and -playback       */ 
/*__________________________________________________________*/


#if (ASYS_TIMEOPTION != ASYS_TIMESYNC)

/***********************************************************/
/*         synchronizes on k-rate boundaries               */
/***********************************************************/

float ksync()

{
  float ret;
  long comptime;

  if (asysio_reset)
    {
      if (asysio_recover()==ASYS_ERROR)
	epr(0,NULL,NULL, "Soundcard error -- failed recovery.");
      asysio_sync_target = asysio_sync_incr;
      ret = 1.0F;
    }
  else
    {

      ASYSIO_IOCTL_CALL(asysio_fd, SNDCTL_DSP_GETOPTR, &asysio_sync_ptr);

      if (asysio_sync_target == asysio_sync_incr)
	ret = 0.0F;
      else
	{
	  comptime = asysio_sync_ptr.bytes - asysio_blocktime;
	  if (comptime > asysio_sync_target)
	    ret = 1.0F;
	  else
	    ret = (asysio_sync_cpuscale*
		   (asysio_sync_incr - (asysio_sync_target - comptime)));
	}
      
      if ((asysio_sync_target = asysio_sync_incr + asysio_sync_ptr.bytes) < 0)
	epr(0,NULL,NULL,"Soundcard error -- rollover.");
    }

  /* reset infinite-loop timer */

  if (setitimer(ITIMER_PROF, &asysio_iloop_timer, NULL) < 0)
    {
      fprintf(stderr, "  Runtime Errno Message: %s\n", strerror(errno));
      epr(0,NULL,NULL, "Soundcard error -- Couldn't reset ITIMER_PROF");
    }

#if ASYSIO_USEFIFO

  if (asysio_fifo)
    {
      /* let other processes run if pending too long */

      if (asysio_blocktime)
	asysio_sync_noblock = 0;
      else
	asysio_sync_noblock++;

      if (asysio_sync_noblock > ASYSIO_MAXBLOCK)
	{
	  nanosleep(&asysio_sync_sleeptime, NULL); 
	  asysio_sync_noblock = 0;
	}
    }

#endif

  asysio_blocktime = 0;
  return ret;
}

#endif


#if (ASYS_TIMEOPTION == ASYS_TIMESYNC)

/***********************************************************/
/*         synchronizes on k-rate boundaries               */
/***********************************************************/

float ksync()

{
  float ret;
  long comptime;

  if (!asysio_reset)
    {
      ASYSIO_IOCTL_CALL(asysio_fd, SNDCTL_DSP_GETOPTR, &asysio_sync_ptr);
      if (asysio_sync_ptr.bytes > asysio_sync_target)
	{
	  comptime = asysio_sync_ptr.bytes - asysio_blocktime;
	  if (comptime < asysio_sync_target)
	    ret = (asysio_sync_cpuscale*
		   (asysio_sync_incr - (asysio_sync_target - comptime)));
	  else
	    ret = 1.0F;
	  ret = (asysio_sync_target != asysio_sync_incr) ? ret : 0.0F;
	}
      else
	{	  
	  comptime = asysio_sync_ptr.bytes - asysio_blocktime;
	  ret = (asysio_sync_cpuscale*
		 (asysio_sync_incr - (asysio_sync_target - comptime)));
	  asysio_reset = asysio_input && 
	    ((asysio_sync_target-asysio_sync_ptr.bytes) == asysio_sync_incr);
	  while ((asysio_sync_ptr.bytes < asysio_sync_target) && !asysio_reset)
	    {  
	      ASYSIO_IOCTL_CALL(asysio_fd, SNDCTL_DSP_GETOSPACE, &asysio_info);
	      asysio_reset = (asysio_info.fragments == asysio_info.fragstotal);
	      ASYSIO_IOCTL_CALL(asysio_fd, SNDCTL_DSP_GETOPTR,&asysio_sync_ptr);
	    }
	}
    }
  if (asysio_reset)
    {
      if (asysio_recover()==ASYS_ERROR)
	epr(0,NULL,NULL,"Sound driver error -- failed recovery.");
      ASYSIO_IOCTL_CALL(asysio_fd, SNDCTL_DSP_GETOPTR, &asysio_sync_ptr);
      asysio_sync_target = asysio_sync_ptr.bytes;
      ret = 1.0F;
    }
  if ((asysio_sync_target += asysio_sync_incr) < 0)
    epr(0,NULL,NULL,"Sound driver error -- rollover.");

  /* reset infinite-loop timer */

  if (setitimer(ITIMER_PROF, &asysio_iloop_timer, NULL) < 0)
    {
      fprintf(stderr, "  Runtime Errno Message: %s\n", strerror(errno));
      epr(0,NULL,NULL, "Soundcard error -- Couldn't reset ITIMER_PROF");
    }

#if ASYSIO_USEFIFO

  if (asysio_fifo)
    {
      switch (asysio_sync_state) {
      case ASYSIO_SYNC_ACTIVE:
	if (!csysi_newnote)
	  {
	    asysio_sync_state = ASYSIO_SYNC_WAITING;
	    asysio_sync_waitstart = time(NULL);
	  }
	break;
      case ASYSIO_SYNC_WAITING:
	if (csysi_newnote)
	  asysio_sync_state = ASYSIO_SYNC_ACTIVE;
	else
	  if ((time(NULL) - asysio_sync_waitstart) >= ASYSIO_SYNC_TIMEOUT)
	    {
	      asysio_sync_state = ASYSIO_SYNC_SCHEDOTHER;
	      if (sched_setscheduler(0, SCHED_OTHER, &asysio_otherparam))
		epr(0,NULL,NULL,"internal error -- sched_other unavailable");
	    }
	break;
      case ASYSIO_SYNC_SCHEDOTHER:
	if (csysi_newnote)
	  {
	    asysio_sync_state = ASYSIO_SYNC_ACTIVE;
	    if (sched_setscheduler(0, SCHED_FIFO, &asysio_fifoparam))
	      fprintf(stderr, "  Note: Process no longer root, " 
		      "improved audio quality no longer possible.\n");
	  }
	break;
      }
    }

#endif

  asysio_blocktime = 0;
  return ret;
}

#endif

#endif /* ASYS_KSYNC */

#undef ASYSIO_IOCTL_CALL
#undef ASYSIO_ERROR_RETURN
#undef ASYSIO_ERROR_RETURN_NOERRNO
#undef ASYSIO_LINUX
#undef ASYSIO_FREEBSD
#undef ASYSIO_OSTYPE
#undef ASYSIO_DSPDEV
#undef ASYSIO_AFORMAT
#undef ASYSIO_I  
#undef ASYSIO_O  
#undef ASYSIO_IO 
#undef ASYSIO_FRAGMIN
#undef ASYSIO_LOGFRAGMIN 
#undef ASYSO_LNUMBUFF
#undef ASYSIO_MAXRETRY

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*                    end of soundcard driver                   */
/*______________________________________________________________*/


#undef ASYS_HASOUTPUT
#undef ASYS_KSYNC


#define CSYS_DONE 0
#define CSYS_ERROR 1

#define CSYS_NONE 0
#define CSYS_MIDIEVENTS 1
#define CSYS_EVENTS 3

#define CSYS_MIDI_NUMCHAN  16

#define CSYS_MIDI_SPECIAL  0x70
#define CSYS_MIDI_NOOP     0x70
#define CSYS_MIDI_NEWTEMPO 0x71
#define CSYS_MIDI_ENDTIME  0x72
#define CSYS_MIDI_POWERUP  0x73
#define CSYS_MIDI_NOTEOFF  0x80
#define CSYS_MIDI_NOTEON   0x90
#define CSYS_MIDI_PTOUCH   0xA0
#define CSYS_MIDI_CC       0xB0
#define CSYS_MIDI_PROGRAM  0xC0
#define CSYS_MIDI_CTOUCH   0xD0
#define CSYS_MIDI_WHEEL    0xE0
#define CSYS_MIDI_SYSTEM   0xF0

#define CSYS_MIDI_SYSTEM_SYSEX_START  0xF0
#define CSYS_MIDI_SYSTEM_QFRAME       0xF1
#define CSYS_MIDI_SYSTEM_SONG_PP      0xF2
#define CSYS_MIDI_SYSTEM_SONG_SELECT  0xF3
#define CSYS_MIDI_SYSTEM_UNUSED1      0xF4
#define CSYS_MIDI_SYSTEM_UNUSED2      0xF5
#define CSYS_MIDI_SYSTEM_TUNE_REQUEST 0xF6
#define CSYS_MIDI_SYSTEM_SYSEX_END    0xF7
#define CSYS_MIDI_SYSTEM_CLOCK        0xF8
#define CSYS_MIDI_SYSTEM_TICK         0xF9
#define CSYS_MIDI_SYSTEM_START        0xFA
#define CSYS_MIDI_SYSTEM_CONTINUE     0xFB
#define CSYS_MIDI_SYSTEM_STOP         0xFC
#define CSYS_MIDI_SYSTEM_UNUSED3      0xFD
#define CSYS_MIDI_SYSTEM_SENSE        0xFE
#define CSYS_MIDI_SYSTEM_RESET        0xFF

#define CSYS_MIDI_CC_BANKSELECT_MSB  0x00
#define CSYS_MIDI_CC_MODWHEEL_MSB    0x01
#define CSYS_MIDI_CC_BREATHCNTRL_MSB 0x02
#define CSYS_MIDI_CC_FOOTCNTRL_MSB   0x04
#define CSYS_MIDI_CC_PORTAMENTO_MSB  0x05
#define CSYS_MIDI_CC_DATAENTRY_MSB   0x06
#define CSYS_MIDI_CC_CHANVOLUME_MSB  0x07
#define CSYS_MIDI_CC_BALANCE_MSB     0x08
#define CSYS_MIDI_CC_PAN_MSB         0x0A
#define CSYS_MIDI_CC_EXPRESSION_MSB  0x0B
#define CSYS_MIDI_CC_EFFECT1_MSB     0x0C
#define CSYS_MIDI_CC_EFFECT2_MSB     0x0D
#define CSYS_MIDI_CC_GEN1_MSB        0x10
#define CSYS_MIDI_CC_GEN2_MSB        0x11
#define CSYS_MIDI_CC_GEN3_MSB        0x12
#define CSYS_MIDI_CC_GEN4_MSB        0x13
#define CSYS_MIDI_CC_BANKSELECT_LSB  0x20
#define CSYS_MIDI_CC_MODWHEEL_LSB    0x21
#define CSYS_MIDI_CC_BREATHCNTRL_LSB 0x22
#define CSYS_MIDI_CC_FOOTCNTRL_LSB   0x24
#define CSYS_MIDI_CC_PORTAMENTO_LSB  0x25
#define CSYS_MIDI_CC_DATAENTRY_LSB   0x26
#define CSYS_MIDI_CC_CHANVOLUME_LSB  0x27
#define CSYS_MIDI_CC_BALANCE_LSB     0x28
#define CSYS_MIDI_CC_PAN_LSB         0x2A
#define CSYS_MIDI_CC_EXPRESSION_LSB  0x2B
#define CSYS_MIDI_CC_EFFECT1_LSB     0x2C
#define CSYS_MIDI_CC_EFFECT2_LSB     0x2D
#define CSYS_MIDI_CC_GEN1_LSB        0x30
#define CSYS_MIDI_CC_GEN2_LSB        0x31
#define CSYS_MIDI_CC_GEN3_LSB        0x32
#define CSYS_MIDI_CC_GEN4_LSB        0x33
#define CSYS_MIDI_CC_SUSTAIN         0x40
#define CSYS_MIDI_CC_PORTAMENTO      0x41
#define CSYS_MIDI_CC_SUSTENUTO       0x42
#define CSYS_MIDI_CC_SOFTPEDAL       0x43
#define CSYS_MIDI_CC_LEGATO          0x44
#define CSYS_MIDI_CC_HOLD2           0x45
#define CSYS_MIDI_CC_SOUNDCONTROL1   0x46
#define CSYS_MIDI_CC_SOUNDCONTROL2   0x47
#define CSYS_MIDI_CC_SOUNDCONTROL3   0x48
#define CSYS_MIDI_CC_SOUNDCONTROL4   0x49
#define CSYS_MIDI_CC_SOUNDCONTROL5   0x4A
#define CSYS_MIDI_CC_SOUNDCONTROL6   0x4B
#define CSYS_MIDI_CC_SOUNDCONTROL7   0x4C
#define CSYS_MIDI_CC_SOUNDCONTROL8   0x4D
#define CSYS_MIDI_CC_SOUNDCONTROL9   0x4E
#define CSYS_MIDI_CC_SOUNDCONTROL10  0x4F
#define CSYS_MIDI_CC_GEN5            0x50
#define CSYS_MIDI_CC_GEN6            0x51
#define CSYS_MIDI_CC_GEN7            0x52
#define CSYS_MIDI_CC_GEN8            0x53
#define CSYS_MIDI_CC_PORTAMENTOSRC   0x54
#define CSYS_MIDI_CC_EFFECT1DEPTH    0x5B
#define CSYS_MIDI_CC_EFFECT2DEPTH    0x5C
#define CSYS_MIDI_CC_EFFECT3DEPTH    0x5D
#define CSYS_MIDI_CC_EFFECT4DEPTH    0x5E
#define CSYS_MIDI_CC_EFFECT5DEPTH    0x5F
#define CSYS_MIDI_CC_DATAENTRYPLUS   0x60
#define CSYS_MIDI_CC_DATAENTRYMINUS  0x61
#define CSYS_MIDI_CC_ALLSOUNDOFF     0x78
#define CSYS_MIDI_CC_RESETALLCONTROL 0x79
#define CSYS_MIDI_CC_LOCALCONTROL    0x7A
#define CSYS_MIDI_CC_ALLNOTESOFF     0x7B


/*
#    Sfront, a SAOL to C translator    
#    This file: Merged linux/freebsd MIDI Input control driver 
#    Copyright (C) 1999  Regents of the University of California
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License (Version 2) as
#    published by the Free Software Foundation.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#    Maintainer: John Lazzaro, lazzaro@cs.berkeley.edu
*/


#include <fcntl.h>
#include <signal.h>  
#include <sys/time.h>  

/****************************************************************/
/****************************************************************/
/*               MIDI Input control driver for sfront           */ 
/****************************************************************/

#ifndef CSYSI_MIDIDEV
#define CSYSI_MIDIDEV "/dev/midi00"
#endif

#define CSYSI_BUFFSIZE    1024
#define CSYSI_SYSEX_EOX   0xF7

/* set CSYSI_DELAY to 0 to wait for partially completed MIDI commands */
/* waiting for commands decreases variance of the latency, at the     */
/* expense of losing computation cycles                               */

#define CSYSI_DELAY 1

/* variables for SIGALRM for MIDI overrun */

/* period for interrupt: 320us per MIDI byte @ 128 bytes, minus safety zone */

#define CSYSI_ALARMPERIOD  40000

/* maximum number of I/O retries before termination */

#define CSYSI_MAXRETRY 256

sigset_t         csysi_overrun_mask;    /* for masking off overrun interrupt */
struct sigaction csysi_overrun_action;  /* for setting up overrun interrupt  */
struct itimerval csysi_overrun_timer;   /* for setting up overrun timer      */

/* flag for new note on/off */

int csysi_newnote = 0;

/* MIDI parsing state variables */

int csysi_midi = 0;

unsigned char csysi_hold[CSYSI_BUFFSIZE];
int csysi_holdidx = 0;

unsigned char csysi_data[CSYSI_BUFFSIZE];

long csysi_len;
long csysi_cnt;
unsigned char csysi_cmd;
unsigned char csysi_num;
unsigned short csysi_extchan;
unsigned char csysi_ndata = 0xFF;

/****************************************************************/
/*          generic error-checking wrappers                     */
/****************************************************************/

#define  CSYSI_ERROR_RETURN(x) do {\
      fprintf(stderr, "  Error: %s.\n", x);\
      fprintf(stderr, "  Errno Message: %s\n\n", strerror(errno));\
      return CSYS_ERROR; } while (0)

#define  CSYSI_ERROR_TERMINATE(x) do {\
      fprintf(stderr, "  Runtime Errno Message: %s\n", strerror(errno));\
      epr(0,NULL,NULL, "Soundcard error -- " x );}  while (0)


/****************************************************************/
/*         signal handler to catch MIDI buffer overruns         */
/****************************************************************/

void csysi_overrun_handler(int signum) 

{   
  int retry = 0;
  int len;

  while ((len = read(csysi_midi, &(csysi_hold[csysi_holdidx]), 
	     CSYSI_BUFFSIZE-csysi_holdidx)) < 0)
    {
      if (++retry > CSYSI_MAXRETRY)
	CSYSI_ERROR_TERMINATE("Too many I/O retries -- csysi_overrun_handler");

      if (errno == EAGAIN)      /* no data ready */
	break;
      if (errno == EINTR)       /* interrupted, try again */
	continue;

      CSYSI_ERROR_TERMINATE("Couldn't read MIDI device");
    }

  if (len > 0)
    {
      if ((csysi_holdidx += len) >= CSYSI_BUFFSIZE)
	fprintf(stderr, "  Warning: MIDI overrun, data lost\n\n");
    }

  /* reset timer */

  if (setitimer(ITIMER_REAL, &csysi_overrun_timer, NULL) < 0)
    CSYSI_ERROR_TERMINATE("Couldn't reset ITIMER_REAL timer");
}


/****************************************************************/
/*             initialization routine for control               */
/****************************************************************/

int csys_setup(void)
     
{

  csysi_midi = open(CSYSI_MIDIDEV, O_RDONLY|O_NONBLOCK);

  if (csysi_midi == -1)
    CSYSI_ERROR_RETURN("Can't open MIDI input device");

  /* set up mask for overrun timer */
  
  if (sigemptyset(&csysi_overrun_mask) < 0)
    CSYSI_ERROR_RETURN("Couldn't run sigemptyset(overrun) OS call");

  if (sigaddset(&csysi_overrun_mask, SIGALRM) < 0)
    CSYSI_ERROR_RETURN("Couldn't run sigaddset(overrun) OS call");

  /* set up signal handler for overrun timer */
  
  if (sigemptyset(&csysi_overrun_action.sa_mask) < 0)
    CSYSI_ERROR_RETURN("Couldn't run sigemptyset(oaction) OS call");

  csysi_overrun_action.sa_flags = SA_RESTART;
  csysi_overrun_action.sa_handler = csysi_overrun_handler;
  
  if (sigaction(SIGALRM, &csysi_overrun_action, NULL) < 0)
    CSYSI_ERROR_RETURN("Couldn't set up SIGALRM signal handler");

  /* set up timer and arm */

  csysi_overrun_timer.it_value.tv_sec = 0;
  csysi_overrun_timer.it_value.tv_usec = CSYSI_ALARMPERIOD;
  csysi_overrun_timer.it_interval.tv_sec = 0;
  csysi_overrun_timer.it_interval.tv_usec = 0;

  if (setitimer(ITIMER_REAL, &csysi_overrun_timer, NULL) < 0)
    CSYSI_ERROR_RETURN("Couldn't set up ITIMER_REAL timer");

  return CSYS_DONE;
}

/****************************************************************/
/*       unmasks overrun timer at end of MIDI parsing           */
/****************************************************************/

int csysi_midiparseover(void)

{
  if (sigprocmask(SIG_UNBLOCK, &csysi_overrun_mask, NULL) < 0)
    CSYSI_ERROR_TERMINATE("Couldn't unmask MIDI overrun timer");

  return CSYS_NONE;
}

/****************************************************************/
/*             polling routine for new data                     */
/****************************************************************/

int csys_newdata(void)
     
{
  int i;
  int retry = 0;
  int len;

  /* block overrun time and reset it */

  if (sigprocmask(SIG_BLOCK, &csysi_overrun_mask, NULL) < 0)
    CSYSI_ERROR_TERMINATE("Couldn't mask MIDI overrun timer");

  if (setitimer(ITIMER_REAL, &csysi_overrun_timer, NULL) < 0)
    CSYSI_ERROR_TERMINATE("Couldn't reset ITIMER_REAL timer");

  if (!csysi_holdidx)
    {
      while ((len = read(csysi_midi, csysi_hold, CSYSI_BUFFSIZE)) < 0)
	{      
	  if (++retry > CSYSI_MAXRETRY)
	    CSYSI_ERROR_TERMINATE("Too many I/O retries -- csys_newdata(if)");

	  if (errno == EAGAIN)
	    return csysi_midiparseover();   /* no data ready, so leave */
	  if (errno == EINTR)
	    continue;                       /* interrupted, try again */

	  /* all other errors fatal */

	  CSYSI_ERROR_TERMINATE("Couldn't read MIDI device");
	}
    }
  else
    {
      while ((len = read(csysi_midi, &(csysi_hold[csysi_holdidx]), 
	       CSYSI_BUFFSIZE-csysi_holdidx)) < 0)
	{
	  if (++retry > CSYSI_MAXRETRY)
	    CSYSI_ERROR_TERMINATE("Too many I/O retries -- csys_newdata(el)");

	  if (errno == EAGAIN)
	    break;                      /* no data ready, process buffer */
	  if (errno == EINTR)
	    continue;                   /* interrupted, try again */

	  /* all other errors fatal */

	  CSYSI_ERROR_TERMINATE("Couldn't read MIDI device");
	}

      len = (len < 0) ? csysi_holdidx : len + csysi_holdidx;
      csysi_holdidx = 0;
    }

  csysi_newnote = csysi_len = csysi_cnt = 0;

  for (i = 0; i < len; i++)
    if (csysi_hold[i] <= CSYSI_SYSEX_EOX)
      csysi_data[csysi_len++] = csysi_hold[i];

  if (!csysi_len) 
    return csysi_midiparseover();

  /* leave interrupts locked until all data transferred */

  return CSYS_MIDIEVENTS;
  
}

/****************************************************************/
/*             gets one byte from MIDI stream                   */
/****************************************************************/

unsigned char csysi_getbyte(void)

{
  unsigned char d;
  int retry = 0;

  /* used when we need to risk waiting for the next byte */

  while (1)
    {
      if (read(csysi_midi, &d, 1) != 1)
	{
	  if (errno == EAGAIN) /* no data ready  */
	    {
	      retry = 0;
	      continue;
	    }
	  if (errno == EINTR) /* interrupted */
	    {	  
	      if (++retry > CSYSI_MAXRETRY)
		CSYSI_ERROR_TERMINATE("Too many I/O retries -- csysi_getbyte");
	      continue;
	    }
	  CSYSI_ERROR_TERMINATE("Couldn't read MIDI device");
	}
      else
	{
	  retry = 0;
	  if (d <= CSYSI_SYSEX_EOX)
	    break;
	  else
	    continue;
	}
    }

  return d;

}

/****************************************************************/
/*             flushes MIDI system messages                     */
/****************************************************************/

int csysi_sysflush(unsigned short type)

{
  unsigned char byte;

  if ((type == 6) || /* one-byte messages */
      (type == 1) || /* undefined messages */
      (type == 4) ||
      (type == 5))
    { 
      if (csysi_cnt == csysi_len)
	return csysi_midiparseover();
      else
	return CSYS_MIDIEVENTS;
    }
  
  if (type == 3) /* song select -- 1 data byte */
    {
      if (csysi_cnt == csysi_len)
	csysi_getbyte();
      else
	csysi_cnt++;
      if (csysi_cnt == csysi_len)
	return csysi_midiparseover();
      else
	return CSYS_MIDIEVENTS;
    }
  
  if (type == 2) /* song pointer -- 2 data bytes */
    {
      if (csysi_cnt < csysi_len)
	csysi_cnt++;
      else
	csysi_getbyte();
      if (csysi_cnt < csysi_len)
	csysi_cnt++;
      else
	csysi_getbyte();
      if (csysi_cnt == csysi_len)
	return csysi_midiparseover();
      else
	return CSYS_MIDIEVENTS;
    }

  if (type == 0) 
    {
      if (csysi_cnt < csysi_len)
	byte = csysi_data[csysi_cnt++];
      else
	byte = csysi_getbyte();
      while (byte < CSYS_MIDI_NOTEOFF)
	if (csysi_cnt < csysi_len)
	  byte = csysi_data[csysi_cnt++];
	else
	  byte = csysi_getbyte();
      if (byte != CSYSI_SYSEX_EOX) /* non-compliant MIDI */
	{
	  if ((byte&0xF0) != 0xF0)
	    {
	      csysi_cmd = byte&0xF0;
	      csysi_extchan = byte&0x0F;
	    }
	  switch (byte&0xF0) {
	  case CSYS_MIDI_NOTEOFF:
	  case CSYS_MIDI_NOTEON:
	  case CSYS_MIDI_PTOUCH:
	  case CSYS_MIDI_WHEEL:
	  case CSYS_MIDI_CC:
	    csysi_num = 2;
	    break;
	  case CSYS_MIDI_PROGRAM:
	  case CSYS_MIDI_CTOUCH:
	    csysi_num = 1;
	    break;
	  case 0xF0: 
	    if ((byte&0x0F)==2) /* song pointer -- 2 data bytes */
	      {
		if (csysi_cnt < csysi_len)
		  csysi_cnt++;
		else
		  csysi_getbyte();
		if (csysi_cnt < csysi_len)
		  csysi_cnt++;
		else
		  csysi_getbyte();
	      }
	    if ((byte&0x0F)==3) /* song select -- 1 data byte */
	      {
		if (csysi_cnt < csysi_len)
		  csysi_cnt++;
		else
		  csysi_getbyte();
	      }
	    break;
	  }
	}
    }

  /* outside of if {} to catch errant F7 bytes */

  if (csysi_cnt == csysi_len)
    return csysi_midiparseover();
  else
    return CSYS_MIDIEVENTS;

}


/****************************************************************/
/*                 processes a MIDI event                       */
/****************************************************************/

int csys_midievent(unsigned char * cmd,   unsigned char * ndata, 
	           unsigned char * vdata, unsigned short * extchan,
		   float * fval)

{
  unsigned char overflow[2], oval;
  int len, tot, idx;


  if (csysi_data[csysi_cnt] > 127)    /* a command byte */
    {
      *cmd = 0xF0 & csysi_data[csysi_cnt];
      *extchan = 0x0F & csysi_data[csysi_cnt];
      if (*cmd != 0xF0)
	{
	  csysi_cmd = *cmd;
	  csysi_extchan = *extchan;
	}
      csysi_cnt++;
      switch (*cmd) {
      case CSYS_MIDI_NOTEOFF:
      case CSYS_MIDI_NOTEON:
      case CSYS_MIDI_PTOUCH:
      case CSYS_MIDI_WHEEL:
      case CSYS_MIDI_CC:
	csysi_num = 2;
	if (CSYSI_DELAY && ((csysi_cnt + 1) == csysi_len)) /* delay cmd */
	  {
	    csysi_ndata = csysi_data[csysi_cnt];
	    *cmd = CSYS_MIDI_NOOP;
	    return csysi_midiparseover();
	  }
	break;
      case CSYS_MIDI_PROGRAM:
      case CSYS_MIDI_CTOUCH:
	csysi_num = 1;
	break;
      case 0xF0: 
	*cmd = CSYS_MIDI_NOOP;
	return csysi_sysflush(*extchan);
	break;
      }
      if (CSYSI_DELAY && (csysi_cnt == csysi_len)) /* delay cmd */
	{
	  *cmd = CSYS_MIDI_NOOP;
	  return csysi_midiparseover();
	}
    }
  else  /* running status or a delayed MIDI command */
    {
      *cmd = csysi_cmd;
      *extchan = csysi_extchan;
      if (CSYSI_DELAY && (csysi_ndata != 0xFF)) /* finish delayed cmd */
	{
	  *ndata = csysi_ndata;
	  csysi_ndata = 0xFF;
	  csysi_newnote |= (((*cmd) == CSYS_MIDI_NOTEON) |
			    ((*cmd) == CSYS_MIDI_NOTEOFF));
	  *vdata = csysi_data[csysi_cnt++];
	  if (csysi_cnt == csysi_len)
	    return csysi_midiparseover();
	  else
	    return CSYS_MIDIEVENTS;
	}
      if (CSYSI_DELAY && (csysi_num == 2) && /* (further) delay cmd */
	  (csysi_cnt + 1 == csysi_len))
	{
	  csysi_ndata = csysi_data[csysi_cnt];
	  *cmd = CSYS_MIDI_NOOP;
	  return csysi_midiparseover();
	}
    }

  /* do complete commands and finish some types of delayed commands */

  if (csysi_cnt + csysi_num <= csysi_len)
    {
      csysi_newnote |= (((*cmd) == CSYS_MIDI_NOTEON) |
			((*cmd) == CSYS_MIDI_NOTEOFF));
      *ndata = csysi_data[csysi_cnt++];
      if (csysi_num == 2)
	*vdata = csysi_data[csysi_cnt++];
      if (csysi_cnt == csysi_len)
	return csysi_midiparseover();
      else
	return CSYS_MIDIEVENTS;
    }

  /* should never execute if CSYSI_DELAY is 1 */

  csysi_newnote |= (((*cmd) == CSYS_MIDI_NOTEON) |
		    ((*cmd) == CSYS_MIDI_NOTEOFF));

  tot = csysi_cnt + csysi_num - csysi_len;
  idx = 0;
  while (tot > 0)
    {
      overflow[idx++] = csysi_getbyte();
      tot--;
    }
  if (csysi_num == 1) 
    {
      *ndata = overflow[0];
      return csysi_midiparseover();
    }
  if (csysi_cnt + 1 == csysi_len)
    {
      *ndata = csysi_data[csysi_cnt++];
      *vdata = overflow[0];
    }
  else
    {
      *ndata = overflow[0];
      *vdata = overflow[1];
    }
  return csysi_midiparseover();
  
}


/****************************************************************/
/*                  closing routine for control                 */
/****************************************************************/

void csys_shutdown(void)
     
{
  /* disarm timer */

  if (sigprocmask(SIG_BLOCK, &csysi_overrun_mask, NULL) < 0)
    CSYSI_ERROR_TERMINATE("Couldn't mask MIDI overrun time");

  csysi_overrun_timer.it_value.tv_sec = 0;
  csysi_overrun_timer.it_value.tv_usec = 0;
  csysi_overrun_timer.it_interval.tv_sec = 0;
  csysi_overrun_timer.it_interval.tv_usec = 0;

  if (setitimer(ITIMER_REAL, &csysi_overrun_timer, NULL) < 0)
    CSYSI_ERROR_TERMINATE("Couldn't disarm ITIMER_REAL timer");

  close(csysi_midi);
}


#undef CSYSI_MIDIDEV
#undef CSYSI_BUFFSIZE
#undef CSYSI_SYSEX_EOX
#undef CSYSI_DELAY
#undef CSYSI_ALARMPERIOD
#undef CSYSI_ERROR_RETURN
#undef CSYSI_ERROR_TERMINATE




float linbuzz__sym_max4(struct ninstr_types * nstate)
{
   float va_x2;
   float x1;
   float ret;

   x1 =  ( NV(linbuzz_vel) -  75.8635F )
 *  6.253596e-02F ;
   va_x2 =  (-2.0F)  ;
   x1 = (x1 > va_x2) ? x1 : va_x2;
   return(NV(linbuzz_max4_return) = x1);

}



float linbuzz__sym_min5(struct ninstr_types * nstate)
{
   float va_x2;
   float x1;
   float ret;

   x1 =  2.0F ;
   va_x2 = linbuzz__sym_max4(NSP) ;
   x1 = (x1 < va_x2) ? x1 : va_x2;
   return(NV(linbuzz_min5_return) = x1);

}



float linbuzz__sym_port6(struct ninstr_types * nstate)
{
   float htime;
   float ctrl;
   float ret;
   float diff;

   ctrl =  (  7.874016e-03F  *  NG(259*NS(iline->numchan) + 0 +  1  ) )
;
   htime =  3.809524e-03F ;
   if (NVI(linbuzz_port6_first))
   {
     if (!NVI(linbuzz_port6_done) || (NV(linbuzz_port6_new) != ctrl))
      {
        if (htime != NV(linbuzz_port6_ohtime))
         {
           NV(linbuzz_port6_ohtime) = htime;
           if (htime != 0.0F)
           {
             NV(linbuzz_port6_sl)=(float)pow(2.0F,-KTIME/htime);
             NV(linbuzz_port6_int)=NV(linbuzz_port6_new)*(1.0F-NV(linbuzz_port6_sl));
           }
         }
       if ((NV(linbuzz_port6_new) != ctrl)||(htime == 0.0F))
        {
          NV(linbuzz_port6_new)=ctrl;
          if (htime == 0.0F)
            NV(linbuzz_port6_curr) = ctrl;
          else
           {
            NVI(linbuzz_port6_done) = 0;
            NV(linbuzz_port6_int)=NV(linbuzz_port6_new)*(1.0F-NV(linbuzz_port6_sl));
           }
        }
       diff = NV(linbuzz_port6_new)-NV(linbuzz_port6_curr);
       if ( (diff > 1e-10F) || (diff < -1e-10F))
         NV(linbuzz_port6_curr)=NV(linbuzz_port6_int)+NV(linbuzz_port6_curr)*NV(linbuzz_port6_sl);
       else
        {
          NV(linbuzz_port6_curr) = NV(linbuzz_port6_new);
          NVI(linbuzz_port6_done) = 1;
        }
     }
   }
   else 
   {
     NVI(linbuzz_port6_done) = NVI(linbuzz_port6_first) = 1;
     NV(linbuzz_port6_new)=NV(linbuzz_port6_curr)=ctrl;
     NV(linbuzz_port6_ohtime)=0.0F;
   }
   ret = NV(linbuzz_port6_curr);
   return((NV(linbuzz_port6_return) = ret));

}



float linbuzz__sym_port7(struct ninstr_types * nstate)
{
   float htime;
   float ctrl;
   float ret;
   float diff;

   ctrl =  (  1.220703e-04F  *  (  NG(259*NS(iline->numchan)+257) -  8192.0F )
)
;
   htime =  3.809524e-03F ;
   if (NVI(linbuzz_port7_first))
   {
     if (!NVI(linbuzz_port7_done) || (NV(linbuzz_port7_new) != ctrl))
      {
        if (htime != NV(linbuzz_port7_ohtime))
         {
           NV(linbuzz_port7_ohtime) = htime;
           if (htime != 0.0F)
           {
             NV(linbuzz_port7_sl)=(float)pow(2.0F,-KTIME/htime);
             NV(linbuzz_port7_int)=NV(linbuzz_port7_new)*(1.0F-NV(linbuzz_port7_sl));
           }
         }
       if ((NV(linbuzz_port7_new) != ctrl)||(htime == 0.0F))
        {
          NV(linbuzz_port7_new)=ctrl;
          if (htime == 0.0F)
            NV(linbuzz_port7_curr) = ctrl;
          else
           {
            NVI(linbuzz_port7_done) = 0;
            NV(linbuzz_port7_int)=NV(linbuzz_port7_new)*(1.0F-NV(linbuzz_port7_sl));
           }
        }
       diff = NV(linbuzz_port7_new)-NV(linbuzz_port7_curr);
       if ( (diff > 1e-10F) || (diff < -1e-10F))
         NV(linbuzz_port7_curr)=NV(linbuzz_port7_int)+NV(linbuzz_port7_curr)*NV(linbuzz_port7_sl);
       else
        {
          NV(linbuzz_port7_curr) = NV(linbuzz_port7_new);
          NVI(linbuzz_port7_done) = 1;
        }
     }
   }
   else 
   {
     NVI(linbuzz_port7_done) = NVI(linbuzz_port7_first) = 1;
     NV(linbuzz_port7_new)=NV(linbuzz_port7_curr)=ctrl;
     NV(linbuzz_port7_ohtime)=0.0F;
   }
   ret = NV(linbuzz_port7_curr);
   return((NV(linbuzz_port7_return) = ret));

}



float linbuzz__sym_max8(struct ninstr_types * nstate)
{
   float va_x2;
   float x1;
   float ret;

   x1 =  ( linbuzz__sym_port7(NSP))
;
   va_x2 =  0.0F  ;
   x1 = (x1 > va_x2) ? x1 : va_x2;
   return(NV(linbuzz_max8_return) = x1);

}



float linbuzz__sym_koscil10(struct ninstr_types * nstate)
{
   float freq;
   int t;
   float ret;
   int i;
   float index;

   t =  TBL_GBL__sym_mtab_0 ;

#undef AP1
#define AP1 gtables[t]

   freq =  6.0F  + (2.0F*(RMULT*((float)rand()) - 0.5F)*( 0.1F ));
   if (NVI(linbuzz_koscil10_first))
   {
     if ((NV(linbuzz_koscil10_p) += KTIME*freq) > 1.0F)
       NV(linbuzz_koscil10_p) -= (int)NV(linbuzz_koscil10_p);
     if (NV(linbuzz_koscil10_p) < 0.0F)
        NV(linbuzz_koscil10_p) += 1 - (int)NV(linbuzz_koscil10_p);
     i = (int) (index = NV(linbuzz_koscil10_p)*AP1.lenf);
     ret = AP1.t[i] + (index - i)*(AP1.t[i+1] - AP1.t[i]);
   }
   else
    {
      NVI(linbuzz_koscil10_first) = 1;
      ret = AP1.t[0];
     }
   return((NV(linbuzz_koscil10_return) = ret));

}



float linbuzz__sym_port11(struct ninstr_types * nstate)
{
   float htime;
   float ctrl;
   float ret;
   float diff;

   ctrl =  (  1.220703e-04F  *  (  NG(259*NS(iline->numchan)+257) -  8192.0F )
)
;
   htime =  3.809524e-03F ;
   if (NVI(linbuzz_port11_first))
   {
     if (!NVI(linbuzz_port11_done) || (NV(linbuzz_port11_new) != ctrl))
      {
        if (htime != NV(linbuzz_port11_ohtime))
         {
           NV(linbuzz_port11_ohtime) = htime;
           if (htime != 0.0F)
           {
             NV(linbuzz_port11_sl)=(float)pow(2.0F,-KTIME/htime);
             NV(linbuzz_port11_int)=NV(linbuzz_port11_new)*(1.0F-NV(linbuzz_port11_sl));
           }
         }
       if ((NV(linbuzz_port11_new) != ctrl)||(htime == 0.0F))
        {
          NV(linbuzz_port11_new)=ctrl;
          if (htime == 0.0F)
            NV(linbuzz_port11_curr) = ctrl;
          else
           {
            NVI(linbuzz_port11_done) = 0;
            NV(linbuzz_port11_int)=NV(linbuzz_port11_new)*(1.0F-NV(linbuzz_port11_sl));
           }
        }
       diff = NV(linbuzz_port11_new)-NV(linbuzz_port11_curr);
       if ( (diff > 1e-10F) || (diff < -1e-10F))
         NV(linbuzz_port11_curr)=NV(linbuzz_port11_int)+NV(linbuzz_port11_curr)*NV(linbuzz_port11_sl);
       else
        {
          NV(linbuzz_port11_curr) = NV(linbuzz_port11_new);
          NVI(linbuzz_port11_done) = 1;
        }
     }
   }
   else 
   {
     NVI(linbuzz_port11_done) = NVI(linbuzz_port11_first) = 1;
     NV(linbuzz_port11_new)=NV(linbuzz_port11_curr)=ctrl;
     NV(linbuzz_port11_ohtime)=0.0F;
   }
   ret = NV(linbuzz_port11_curr);
   return((NV(linbuzz_port11_return) = ret));

}



float linbuzz__sym_max12(struct ninstr_types * nstate)
{
   float va_x2;
   float x1;
   float ret;

   x1 =  -  ( linbuzz__sym_port11(NSP))
;
   va_x2 =  0.0F  ;
   x1 = (x1 > va_x2) ? x1 : va_x2;
   return(NV(linbuzz_max12_return) = x1);

}



float linbuzz__sym_koscil14(struct ninstr_types * nstate)
{
   float freq;
   int t;
   float ret;
   int i;
   float index;

   t =  TBL_GBL__sym_mtab_0 ;

#undef AP1
#define AP1 gtables[t]

   freq =  5.0F  + (2.0F*(RMULT*((float)rand()) - 0.5F)*( 0.1F ));
   if (NVI(linbuzz_koscil14_first))
   {
     if ((NV(linbuzz_koscil14_p) += KTIME*freq) > 1.0F)
       NV(linbuzz_koscil14_p) -= (int)NV(linbuzz_koscil14_p);
     if (NV(linbuzz_koscil14_p) < 0.0F)
        NV(linbuzz_koscil14_p) += 1 - (int)NV(linbuzz_koscil14_p);
     i = (int) (index = NV(linbuzz_koscil14_p)*AP1.lenf);
     ret = AP1.t[i] + (index - i)*(AP1.t[i+1] - AP1.t[i]);
   }
   else
    {
      NVI(linbuzz_koscil14_first) = 1;
      ret = AP1.t[0];
     }
   return((NV(linbuzz_koscil14_return) = ret));

}



float linbuzz__sym_buzz15(struct ninstr_types * nstate)
{
   float rolloff;
   float lowharm;
   float nharm;
   float cps;
   float ret;
   int tnharm;
   double dscale;
   float denom, q, n, rad;
   float c1, c2, c3, s1, s2, s3;

   cps = NV(linbuzz_f);
   nharm =  (-1.0F) ;
   lowharm =  0.0F ;
   rolloff = NV(linbuzz_bright);
   if (acycleidx)
   {
   if ((NV(linbuzz_buzz15_p) += NV(linbuzz_buzz15_d)) >= 1.0F)
    NV(linbuzz_buzz15_p) -= (int)NV(linbuzz_buzz15_p);
     if (NV(linbuzz_buzz15_p) < 0.0F)
      NV(linbuzz_buzz15_p) += 1 - (int)NV(linbuzz_buzz15_p);
     if ((q = NV(linbuzz_buzz15_p)*NV(linbuzz_buzz15_qtab)) >= 1.0F)
      q -= (int)q;
     if ((n = NV(linbuzz_buzz15_p)*NV(linbuzz_buzz15_ntab)) >= 1.0F)
      n -= (int)n;
     c1 = NV(linbuzz_buzz15_r)*TCOS(rad = TRIGSIZEF*NV(linbuzz_buzz15_p));
     s1 = NV(linbuzz_buzz15_r)*TSIN(rad);
     c2 = NV(linbuzz_buzz15_k2)*TCOS(rad = TRIGSIZEF*n);
     s2 = NV(linbuzz_buzz15_k2)*TSIN(rad);
     c3 = NV(linbuzz_buzz15_scale)*TCOS(rad = TRIGSIZEF*q);
     s3 = NV(linbuzz_buzz15_scale)*TSIN(rad);
     if ((denom = (NV(linbuzz_buzz15_k1)-c1-c1)) > BUZZDIVISOR)
      {
        ret = ((1.0F-c1)*(c3-c2) + s1*(s2-s3))/denom;
      }
     else
      {
       c1 = NV(linbuzz_buzz15_r)*cos(rad = 6.283185F*NV(linbuzz_buzz15_p));
       s1 = NV(linbuzz_buzz15_r)*sin(rad);
       c2 = NV(linbuzz_buzz15_k2)*cos(rad = 6.283185F*n);
       s2 = NV(linbuzz_buzz15_k2)*sin(rad);
       c3 = NV(linbuzz_buzz15_scale)*cos(rad = 6.283185F*q);
       s3 = NV(linbuzz_buzz15_scale)*sin(rad);
       denom = NV(linbuzz_buzz15_k1)-c1-c1;
       ret = ((1.0F-c1)*(c3-c2) + s1*(s2-s3))/denom;
      }
   }
   else
   {
     if (lowharm < 0.0F)
   epr(116,"linbuzz.saol","buzz","Lowharm < 0");
     tnharm = (int)((0.5F*ARATE/((cps>1.0F)?cps:1.0F))-lowharm-1.0F);
     if ((nharm > 0.0F) && (nharm < tnharm))
       tnharm = (int)nharm;
     NV(linbuzz_buzz15_qtab)=(float)(1+(int)lowharm);
     NV(linbuzz_buzz15_ntab)=(float)(2+tnharm+(int)lowharm);
     NV(linbuzz_buzz15_r) = rolloff;
     if ((rolloff > BUZZMINVAL) && (rolloff < BUZZMAXVAL))
      rolloff = NV(linbuzz_buzz15_r) = BUZZMINVAL;
     if ((rolloff < - BUZZMINVAL) && (rolloff > - BUZZMAXVAL))
      rolloff = NV(linbuzz_buzz15_r) = - BUZZMINVAL;
     NV(linbuzz_buzz15_k1)= 1 + rolloff*rolloff;
     if (rolloff)
      {
       dscale=pow((double)rolloff,(double)(tnharm+1));
       if (rolloff > 0.0F)
        {
          NV(linbuzz_buzz15_k2) = (1-rolloff)/((1.0/dscale)-1.0);
          NV(linbuzz_buzz15_scale) = (1.0-rolloff)/(1.0-dscale);
        }
       else
        {
          NV(linbuzz_buzz15_k2) = (1.0+rolloff)/((1.0/dscale)+((tnharm&1)?-1.0:1.0));
          NV(linbuzz_buzz15_scale) = (1.0+rolloff)/(1.0-fabs(dscale));
        }
      }
     else
      {
         NV(linbuzz_buzz15_scale)= 1.0F;
         NV(linbuzz_buzz15_k2)=0.0F;
      }
     NV(linbuzz_buzz15_d) = ATIME*cps;
     if (NVI(linbuzz_buzz15_kcyc) != 0)
      {
   if ((NV(linbuzz_buzz15_p) += NV(linbuzz_buzz15_d)) >= 1.0F)
    NV(linbuzz_buzz15_p) -= (int)NV(linbuzz_buzz15_p);
       if (NV(linbuzz_buzz15_p) < 0.0F)
        NV(linbuzz_buzz15_p) += 1 - (int)NV(linbuzz_buzz15_p);
       if ((q = NV(linbuzz_buzz15_p)*NV(linbuzz_buzz15_qtab)) >= 1.0F)
        q -= (int)q;
       if ((n = NV(linbuzz_buzz15_p)*NV(linbuzz_buzz15_ntab)) >= 1.0F)
        n -= (int)n;
      }
     else
        n = q = 0.0F;
       NVI(linbuzz_buzz15_kcyc) = 1;
     c1 = rolloff*TCOS(rad = TRIGSIZEF*NV(linbuzz_buzz15_p));
     s1 = rolloff*TSIN(rad);
     c2 = NV(linbuzz_buzz15_k2)*TCOS(rad = TRIGSIZEF*n);
     s2 = NV(linbuzz_buzz15_k2)*TSIN(rad);
     c3 = NV(linbuzz_buzz15_scale)*TCOS(rad = TRIGSIZEF*q);
     s3 = NV(linbuzz_buzz15_scale)*TSIN(rad);
     if ((denom = (NV(linbuzz_buzz15_k1)-c1-c1)) > BUZZDIVISOR)
      {
        ret = ((1.0F-c1)*(c3-c2) + s1*(s2-s3))/denom;
      }
     else
      {
       c1 = rolloff*cos(rad = 6.283185F*NV(linbuzz_buzz15_p));
       s1 = rolloff*sin(rad);
       c2 = NV(linbuzz_buzz15_k2)*cos(rad = 6.283185F*n);
       s2 = NV(linbuzz_buzz15_k2)*sin(rad);
       c3 = NV(linbuzz_buzz15_scale)*cos(rad = 6.283185F*q);
       s3 = NV(linbuzz_buzz15_scale)*sin(rad);
       denom = NV(linbuzz_buzz15_k1)-c1-c1;
       ret = ((1.0F-c1)*(c3-c2) + s1*(s2-s3))/denom;
      }
   }
   return((NV(linbuzz_buzz15_return) = ret));

}


#undef NS
#define NS(x)  ninstr[0].x
#undef NSP
#define NSP  /* void */
#undef NT
#define NT(x)  ninstr[0].t[x]
#undef NV
#define NV(x)  ninstr[0].v[x].f
#undef NVI
#define NVI(x)  ninstr[0].v[x].i
#undef NVU
#define NVU(x)  ninstr[0].v[x]
#undef NP
#define NP(x)  ninstr[0].v[x].f
#undef NPI
#define NPI(x)  ninstr[0].v[x].i



float mix1__sym_port1(void)
{
   float htime;
   float ctrl;
   float ret;
   float diff;

   ctrl =  (  7.874016e-03F  *  NG(259*NS(iline->numchan) + 0 +  7  ) )
;
   htime =  3.809524e-03F ;
   if (NVI(mix1_port1_first))
   {
     if (!NVI(mix1_port1_done) || (NV(mix1_port1_new) != ctrl))
      {
        if (htime != NV(mix1_port1_ohtime))
         {
           NV(mix1_port1_ohtime) = htime;
           if (htime != 0.0F)
           {
             NV(mix1_port1_sl)=(float)pow(2.0F,-KTIME/htime);
             NV(mix1_port1_int)=NV(mix1_port1_new)*(1.0F-NV(mix1_port1_sl));
           }
         }
       if ((NV(mix1_port1_new) != ctrl)||(htime == 0.0F))
        {
          NV(mix1_port1_new)=ctrl;
          if (htime == 0.0F)
            NV(mix1_port1_curr) = ctrl;
          else
           {
            NVI(mix1_port1_done) = 0;
            NV(mix1_port1_int)=NV(mix1_port1_new)*(1.0F-NV(mix1_port1_sl));
           }
        }
       diff = NV(mix1_port1_new)-NV(mix1_port1_curr);
       if ( (diff > 1e-10F) || (diff < -1e-10F))
         NV(mix1_port1_curr)=NV(mix1_port1_int)+NV(mix1_port1_curr)*NV(mix1_port1_sl);
       else
        {
          NV(mix1_port1_curr) = NV(mix1_port1_new);
          NVI(mix1_port1_done) = 1;
        }
     }
   }
   else 
   {
     NVI(mix1_port1_done) = NVI(mix1_port1_first) = 1;
     NV(mix1_port1_new)=NV(mix1_port1_curr)=ctrl;
     NV(mix1_port1_ohtime)=0.0F;
   }
   ret = NV(mix1_port1_curr);
   return((NV(mix1_port1_return) = ret));

}


#undef NS
#define NS(x) nstate->x
#undef NSP
#define NSP nstate
#undef NT
#define NT(x)  nstate->t[x]
#undef NV
#define NV(x)  nstate->v[x].f
#undef NVI
#define NVI(x)  nstate->v[x].i
#undef NVU
#define NVU(x)  nstate->v[x]
#undef NP
#define NP(x)  nstate->v[x].f
#undef NPI
#define NPI(x)  nstate->v[x].i

void linbuzz_ipass(struct ninstr_types * nstate)
{
   int i;
   int j;

memset(&(NV(0)), 0, linbuzz_ENDVAR*sizeof(float));
memset(&(NT(0)), 0, linbuzz_ENDTBL*sizeof(struct tableinfo));
   NV(linbuzz_pitch) = 
   NS(iline->p[linbuzz_pitch]);
   NV(linbuzz_vel) = 
   NS(iline->p[linbuzz_vel]);
NV(linbuzz_fbase) = (globaltune*(float)(pow(2.0F, 8.333334e-02F*(-69.0F + NV(linbuzz_pitch)))));
 NV(linbuzz_offset) =  0.1F  *  ( linbuzz__sym_min5(NSP) +  2.0F )
;
 NV(linbuzz_vel) =  0.15F  *  ( NV(linbuzz_offset) +  0.1F )
;
 NV(linbuzz_envc) = NV(linbuzz_vel) *  1.050000e+03F ;
 NV(linbuzz__tvr0) = NV(linbuzz_envc) *  2.267574e-05F ;
 NV(linbuzz__tvr1) = NV(linbuzz_envc) *  9.523810e-04F ;
 
}


#undef NS
#define NS(x)  ninstr[0].x
#undef NSP
#define NSP  /* void */
#undef NT
#define NT(x)  ninstr[0].t[x]
#undef NV
#define NV(x)  ninstr[0].v[x].f
#undef NVI
#define NVI(x)  ninstr[0].v[x].i
#undef NVU
#define NVU(x)  ninstr[0].v[x]
#undef NP
#define NP(x)  ninstr[0].v[x].f
#undef NPI
#define NPI(x)  ninstr[0].v[x].i

void mix1_ipass(void)
{
   int i;

memset(&(NV(0)), 0, mix1_ENDVAR*sizeof(float));
memset(&(NT(0)), 0, mix1_ENDTBL*sizeof(struct tableinfo));

}


#undef NS
#define NS(x) nstate->x
#undef NSP
#define NSP nstate
#undef NT
#define NT(x)  nstate->t[x]
#undef NV
#define NV(x)  nstate->v[x].f
#undef NVI
#define NVI(x)  nstate->v[x].i
#undef NVU
#define NVU(x)  nstate->v[x]
#undef NP
#define NP(x)  nstate->v[x].f
#undef NPI
#define NPI(x)  nstate->v[x].i

void linbuzz_kpass(struct ninstr_types * nstate)
{

   int i;

   NS(iline->itime) = ((float)(kcycleidx - NS(iline->kbirth)))*KTIME;

NV(linbuzz_incr) =  0.0F ;
  if  (  ((float)NS(iline->released))  &&  ! NV(linbuzz_rel))
 { NV(linbuzz_rel) =  1.0F ;
   if ((NS(iline->sdur) < 0.0F)||
   (NS(iline->turnoff)&&NS(iline->released)))
  {
    NS(iline->endtime) = scorebase;
    NS(iline->endabs) = (kbase - 1)*KTIME;
    NS(iline->sdur) = 0.0F;
  }
  NS(iline->abstime) += 
 6.000000e-02F   ;
   if (NS(iline->released))
    NS(iline->turnoff) = 0;
}
 if  (  (  ! NV(linbuzz_rel))
 &&  (  NS(iline->itime)  <  4.761905e-04F )
)
 { NV(linbuzz_incr) = NV(linbuzz__tvr0);
 NV(linbuzz_tot) = NV(linbuzz_tot) + NV(linbuzz__tvr1);
 }
 if  ( NV(linbuzz_rel))
 { NV(linbuzz_incr) =  - NV(linbuzz_tot) *  2.267574e-05F  *  1.615385e+01F ;
 }
NV(linbuzz_bright) =  0.5F  +  ( linbuzz__sym_port6(NSP))
 * NV(linbuzz_offset);
 NV(linbuzz_mod) =  0.005793F  *  ( linbuzz__sym_max8(NSP) * linbuzz__sym_koscil10(NSP) + linbuzz__sym_max12(NSP) * linbuzz__sym_koscil14(NSP))
;
 NV(linbuzz_f) =  ( NV(linbuzz_mod) +  1.0F )
 * NV(linbuzz_fbase);
 
}


#undef NS
#define NS(x)  ninstr[0].x
#undef NSP
#define NSP  /* void */
#undef NT
#define NT(x)  ninstr[0].t[x]
#undef NV
#define NV(x)  ninstr[0].v[x].f
#undef NVI
#define NVI(x)  ninstr[0].v[x].i
#undef NVU
#define NVU(x)  ninstr[0].v[x]
#undef NP
#define NP(x)  ninstr[0].v[x].f
#undef NPI
#define NPI(x)  ninstr[0].v[x].i

void mix1_kpass(void)
{

   int i;

NV(mix1__tvr0) =  ( mix1__sym_port1(NSP))
;
 
}


#undef NS
#define NS(x) nstate->x
#undef NSP
#define NSP nstate
#undef NT
#define NT(x)  nstate->t[x]
#undef NV
#define NV(x)  nstate->v[x].f
#undef NVI
#define NVI(x)  nstate->v[x].i
#undef NVU
#define NVU(x)  nstate->v[x]
#undef NP
#define NP(x)  nstate->v[x].f
#undef NPI
#define NPI(x)  nstate->v[x].i

void linbuzz_apass(struct ninstr_types * nstate)
{

NV(linbuzz_y) = linbuzz__sym_buzz15(NSP);
 NV(linbuzz_env) = NV(linbuzz_env) + NV(linbuzz_incr);
 TB(BUS_output_bus + 0) += NV(linbuzz_env) * NV(linbuzz_y);
}


#undef NS
#define NS(x)  ninstr[0].x
#undef NSP
#define NSP  /* void */
#undef NT
#define NT(x)  ninstr[0].t[x]
#undef NV
#define NV(x)  ninstr[0].v[x].f
#undef NVI
#define NVI(x)  ninstr[0].v[x].i
#undef NVU
#define NVU(x)  ninstr[0].v[x]
#undef NP
#define NP(x)  ninstr[0].v[x].f
#undef NPI
#define NPI(x)  ninstr[0].v[x].i

void mix1_apass(void)
{

   STB(BUS_output_bus + 0) = TB(BUS_output_bus + 0);
   TB(BUS_output_bus + 0) = 0.0F;

TB(BUS_output_bus + 0) += NV(mix1__tvr0) *  STB(BUS_output_bus) ;
}


#undef NS
#define NS(x) nstate->x
#undef NSP
#define NSP nstate
#undef NT
#define NT(x)  nstate->t[x]
#undef NV
#define NV(x)  nstate->v[x].f
#undef NVI
#define NVI(x)  nstate->v[x].i
#undef NVU
#define NVU(x)  nstate->v[x]
#undef NP
#define NP(x)  nstate->v[x].f
#undef NPI
#define NPI(x)  nstate->v[x].i


#undef NS
#define NS(x) 0
#undef NSP
#define NSP NULL
#undef NT
#define NT(x)  gtables[x]
#undef NV
#define NV(x)  global[x].f
#undef NVI
#define NVI(x)  global[x].i
#undef NVU
#define NVU(x)  global[x]
#undef NP
#define NP(x)  global[x].f
#undef NPI
#define NPI(x)  global[x].i


#undef NS
#define NS(x) nstate->x
#undef NSP
#define NSP nstate
#undef NT
#define NT(x)  nstate->t[x]
#undef NV
#define NV(x)  nstate->v[x].f
#undef NVI
#define NVI(x)  nstate->v[x].i
#undef NVU
#define NVU(x)  nstate->v[x]
#undef NP
#define NP(x)  nstate->v[x].f
#undef NPI
#define NPI(x)  nstate->v[x].i

float table_global__sym_mtab_0[129] = { 
0.0F,3.125000e-02F,6.250000e-02F,9.375000e-02F,1.250000e-01F,1.562500e-01F,1.875000e-01F,2.187500e-01F,
2.500000e-01F,2.812500e-01F,3.125000e-01F,3.437500e-01F,3.750000e-01F,4.062500e-01F,4.375000e-01F,4.687500e-01F,
5.000000e-01F,5.312500e-01F,5.625000e-01F,5.937500e-01F,6.250000e-01F,6.562500e-01F,6.875000e-01F,7.187500e-01F,
7.500000e-01F,7.812500e-01F,8.125000e-01F,8.437500e-01F,8.750000e-01F,9.062500e-01F,9.375000e-01F,9.687500e-01F,
1.0F,9.687500e-01F,9.375000e-01F,9.062500e-01F,8.750000e-01F,8.437500e-01F,8.125000e-01F,7.812500e-01F,
7.500000e-01F,7.187500e-01F,6.875000e-01F,6.562500e-01F,6.250000e-01F,5.937500e-01F,5.625000e-01F,5.312500e-01F,
5.000000e-01F,4.687500e-01F,4.375000e-01F,4.062500e-01F,3.750000e-01F,3.437500e-01F,3.125000e-01F,2.812500e-01F,
2.500000e-01F,2.187500e-01F,1.875000e-01F,1.562500e-01F,1.250000e-01F,9.375000e-02F,6.250000e-02F,3.125000e-02F,
0.0F,-3.125000e-02F,-6.250000e-02F,-9.375000e-02F,-1.250000e-01F,-1.562500e-01F,-1.875000e-01F,-2.187500e-01F,
-2.500000e-01F,-2.812500e-01F,-3.125000e-01F,-3.437500e-01F,-3.750000e-01F,-4.062500e-01F,-4.375000e-01F,-4.687500e-01F,
-5.000000e-01F,-5.312500e-01F,-5.625000e-01F,-5.937500e-01F,-6.250000e-01F,-6.562500e-01F,-6.875000e-01F,-7.187500e-01F,
-7.500000e-01F,-7.812500e-01F,-8.125000e-01F,-8.437500e-01F,-8.750000e-01F,-9.062500e-01F,-9.375000e-01F,-9.687500e-01F,
-1.0F,-9.677419e-01F,-9.354838e-01F,-9.032257e-01F,-8.709676e-01F,-8.387095e-01F,-8.064514e-01F,-7.741933e-01F,
-7.419353e-01F,-7.096772e-01F,-6.774191e-01F,-6.451610e-01F,-6.129029e-01F,-5.806448e-01F,-5.483867e-01F,-5.161286e-01F,
-4.838705e-01F,-4.516125e-01F,-4.193544e-01F,-3.870963e-01F,-3.548383e-01F,-3.225802e-01F,-2.903222e-01F,-2.580641e-01F,
-2.258060e-01F,-1.935480e-01F,-1.612899e-01F,-1.290318e-01F,-9.677377e-02F,-6.451571e-02F,-3.225765e-02F,0.0F,
0.0F};



#undef NS
#define NS(x) 0
#undef NSP
#define NSP NULL
#undef NT
#define NT(x)  gtables[x]
#undef NV
#define NV(x)  global[x].f
#undef NVI
#define NVI(x)  global[x].i
#undef NVU
#define NVU(x)  global[x]
#undef NP
#define NP(x)  global[x].f
#undef NPI
#define NPI(x)  global[x].i



void system_init(int argc, char **argv)
{

   int i;

   int j;

   srand(((unsigned int)time(0))|1);
   asys_argc = argc;
   asys_argv = argv;

   csys_argc = argc;
   csys_argv = argv;


    /* MIDI volume */

   global[7].f = global[266].f = global[525].f = global[784].f = 
   global[1043].f = global[1302].f = global[1561].f = global[1820].f = 
   global[2079].f = global[2338].f = global[2597].f = global[2856].f = 
   global[3115].f = global[3374].f = global[3633].f = global[3892].f = 
    100.0F; 

    /* MIDI Pan */

   global[10].f = global[269].f = global[528].f = global[787].f = 
   global[1046].f = global[1305].f = global[1564].f = global[1823].f = 
   global[2082].f = global[2341].f = global[2600].f = global[2859].f = 
   global[3118].f = global[3377].f = global[3636].f = global[3895].f = 
    64.0F; 

    /* MIDI Expression */

   global[11].f = global[270].f = global[529].f = global[788].f = 
   global[1047].f = global[1306].f = global[1565].f = global[1824].f = 
   global[2083].f = global[2342].f = global[2601].f = global[2860].f = 
   global[3119].f = global[3378].f = global[3637].f = global[3896].f = 
    127.0F; 

    /* MIDI Bend */

   global[257].f = global[516].f = global[775].f = global[1034].f = 
   global[1293].f = global[1552].f = global[1811].f = global[2070].f = 
   global[2329].f = global[2588].f = global[2847].f = global[3106].f = 
   global[3365].f = global[3624].f = global[3883].f = global[4142].f = 
    8192.0F; 

    /* MIDI Ext Channel Number */

   global[258].f = 0.0F; global[517].f = 1.0F; global[776].f = 2.0F; 
   global[1035].f = 3.0F; global[1294].f = 4.0F; global[1553].f = 5.0F; 
   global[1812].f = 6.0F; global[2071].f = 7.0F; global[2330].f = 8.0F; 
   global[2589].f = 9.0F; global[2848].f = 10.0F; global[3107].f = 11.0F; 
   global[3366].f = 12.0F; global[3625].f = 13.0F; global[3884].f = 14.0F; 
   global[4143].f = 15.0F; 

   memset(&(NV(GBL_STARTVAR)), 0, 
          (GBL_ENDVAR-GBL_STARTVAR)*sizeof(float));
   memset(&(NT(0)), 0, GBL_ENDTBL*sizeof(struct tableinfo));
   NT(TBL_GBL__sym_mtab_0).lenf = (float)(NT(TBL_GBL__sym_mtab_0).len = 128);
   NT(TBL_GBL__sym_mtab_0).tend = 127;
   NT(TBL_GBL__sym_mtab_0).n = NT(TBL_GBL__sym_mtab_0).diff = 0.992188;
   NT(TBL_GBL__sym_mtab_0).t = (float *)(table_global__sym_mtab_0);

#undef NS
#define NS(x) nstate->x
#undef NSP
#define NSP nstate
#undef NT
#define NT(x)  nstate->t[x]
#undef NV
#define NV(x)  nstate->v[x].f
#undef NVI
#define NVI(x)  nstate->v[x].i
#undef NVU
#define NVU(x)  nstate->v[x]
#undef NP
#define NP(x)  nstate->v[x].f
#undef NPI
#define NPI(x)  nstate->v[x].i

   for (busidx=0; busidx<ENDBUS;busidx++)
      TB(busidx)=0.0F;


}


#undef NS
#define NS(x) 0
#undef NSP
#define NSP NULL
#undef NT
#define NT(x)  gtables[x]
#undef NV
#define NV(x)  global[x].f
#undef NVI
#define NVI(x)  global[x].i
#undef NVU
#define NVU(x)  global[x]
#undef NP
#define NP(x)  global[x].f
#undef NPI
#define NPI(x)  global[x].i



void effects_init(void)
{

e_mix[0].noteon = TOBEPLAYED;
e_mix[0].starttime = 0.0F;
e_mix[0].abstime = 0.0F;
e_mix[0].released = 0;
e_mix[0].turnoff = 0;
e_mix[0].time = 0.0F;
e_mix[0].itime = 0.0F;
e_mix[0].sdur = -1.0F;
e_mix[0].kbirth = kbase;
e_mix[0].numchan = midimasterchannel;


}


#undef NS
#define NS(x) nstate->x
#undef NSP
#define NSP nstate
#undef NT
#define NT(x)  nstate->t[x]
#undef NV
#define NV(x)  nstate->v[x].f
#undef NVI
#define NVI(x)  nstate->v[x].i
#undef NVU
#define NVU(x)  nstate->v[x]
#undef NP
#define NP(x)  nstate->v[x].f
#undef NPI
#define NPI(x)  nstate->v[x].i


#undef NS
#define NS(x) 0
#undef NSP
#define NSP NULL
#undef NT
#define NT(x)  gtables[x]
#undef NV
#define NV(x)  global[x].f
#undef NVI
#define NVI(x)  global[x].i
#undef NVU
#define NVU(x)  global[x]
#undef NP
#define NP(x)  global[x].f
#undef NPI
#define NPI(x)  global[x].i



void shut_down(void)
   {

  if (graceful_exit)
    {
      fprintf(stderr, "\nShutting down system ... please wait.\n");
      fprintf(stderr, "If no termination in 10 seconds, use Ctrl-C or Ctrl-\\ to force exit.\n");
      fflush(stderr);
    }
   asys_putbuf(&asys_obuf, &obusidx);
   asys_oshutdown();

   csys_shutdown();

   }

void main_apass(void)

{

 for (sysidx=cm_linbuzz___first;sysidx<=cm_linbuzz___last;sysidx++)
  if (sysidx->noteon == PLAYING)
   linbuzz_apass(sysidx->nstate);
   mix1_apass();

}

int main_kpass(void)

{

 for (sysidx=cm_linbuzz___first;sysidx<=cm_linbuzz___last;sysidx++)
  if (sysidx->noteon == PLAYING)
  {
   linbuzz_kpass(sysidx->nstate);
  }
   mix1_kpass();

  return graceful_exit;
}

void main_ipass(void)

{

int i;

   unsigned char  ndata, vdata;
   unsigned short ec;
   float oldtime;
   struct instr_line * oldest;
   int ne, newevents, netevents;
   unsigned char cmd;
   float fval;

   newevents = csys_newdata();
   if (newevents & CSYS_MIDIEVENTS)
   do
    {
     ne = csys_midievent(&cmd,&ndata,&vdata,&ec,&fval);
     if ((ec < CSYS_MAXEXTCHAN)||((cmd&0xF0)==CSYS_MIDI_SPECIAL))
     switch(cmd&0xF0) {
      case CSYS_MIDI_NOTEON:
      if ((cme_first[ec])==NULL)
        break;
      if (vdata != 0)
       {
        if (*cme_next[ec] == NULL)
          *cme_next[ec] = *cme_first[ec] = *cme_last[ec];
        else
          {
            oldest = NULL;
            oldtime = MAXENDTIME;
            *cme_next[ec] = *cme_first[ec];
            while ((*cme_next[ec]) < (*cme_end[ec]))
      	 {
      	   if (((*cme_next[ec])->noteon == NOTUSEDYET)||
      	       ((*cme_next[ec])->noteon == ALLDONE))
      	     break;
               if ((*cme_next[ec])->starttime < oldtime)
                {
                  oldest =  (*cme_next[ec]);
                  oldtime = (*cme_next[ec])->starttime;
                }
      	   (*cme_next[ec])++;
      	 }
           if ((*cme_next[ec]) == (*cme_end[ec]))
            {
              *cme_next[ec] = oldest;
              oldest->nstate->iline = NULL;
            }
            if ((*cme_next[ec]) > (*cme_last[ec]))
      	    *cme_last[ec] = *cme_next[ec];
          }
        (*cme_next[ec])->starttime = scorebeats - scoremult;
        (*cme_next[ec])->endtime = MAXENDTIME;
        (*cme_next[ec])->abstime = 0.0F;
        (*cme_next[ec])->time = 0.0F;
        (*cme_next[ec])->sdur = -1.0F;
        (*cme_next[ec])->released = 0;
        (*cme_next[ec])->turnoff = 0;
        (*cme_next[ec])->noteon = TOBEPLAYED;
        (*cme_next[ec])->numchan = ec + CSYS_EXTCHANSTART;
        (*cme_next[ec])->preset  = cme_preset[ec];
        (*cme_next[ec])->notenum  = ndata;
        (*cme_next[ec])->p[0] = ndata ;
        (*cme_next[ec])->p[1] = vdata ;
        break;
       }
      case CSYS_MIDI_NOTEOFF:
       if ((cme_first[ec])==NULL)
         break;
       oldest = NULL;
       oldtime = MAXENDTIME;
       for (sysidx=*cme_first[ec];sysidx<=*cme_last[ec];sysidx++)
         if ((sysidx->notenum == ndata) && 
             (sysidx->numchan == ec + CSYS_EXTCHANSTART) &&
             (sysidx->starttime < oldtime))
          {
            oldest = sysidx;
            oldtime = sysidx->starttime;
          }
       if (oldest)
          {
             oldest->endtime = scorebeats - scoremult;
             oldest->notenum += 256;
          }
       break;
      case CSYS_MIDI_PTOUCH:
       NG(CSYS_FRAMELEN*(ec+CSYS_EXTCHANSTART)+CSYS_TOUCHPOS+ndata)=vdata;
      break;
      case CSYS_MIDI_CTOUCH:
       NG(CSYS_FRAMELEN*(ec+CSYS_EXTCHANSTART)+CSYS_CHTOUCHPOS)=vdata;
      break;
      case CSYS_MIDI_WHEEL:
       NG(CSYS_FRAMELEN*(ec + CSYS_EXTCHANSTART) + CSYS_BENDPOS) = 
                                               128*vdata + ndata;
      break;
      case CSYS_MIDI_CC:
       NG(CSYS_FRAMELEN*(ec+CSYS_EXTCHANSTART)+CSYS_CCPOS+ndata)=vdata;
       switch(ndata) {
        case CSYS_MIDI_CC_BANKSELECT_LSB:
         csys_banklsb = vdata;
         csys_bank = csys_banklsb + 128*csys_bankmsb;
         break;
        case CSYS_MIDI_CC_BANKSELECT_MSB:
         csys_bankmsb = vdata;
         csys_bank = csys_banklsb + 128*csys_bankmsb;
         break;
        case CSYS_MIDI_CC_ALLSOUNDOFF:
          if ((cme_first[ec]))
           for (sysidx=*cme_first[ec];sysidx<=*cme_last[ec];sysidx++)
            {
               sysidx->noteon = ALLDONE;
               sysidx->nstate->iline = NULL;
            }
         break;
        case CSYS_MIDI_CC_ALLNOTESOFF:
          if ((cme_first[ec]))
           for (sysidx=*cme_first[ec];sysidx<=*cme_last[ec];sysidx++)
            {
               sysidx->endtime =  scorebeats - scoremult;
               sysidx->notenum += 256;
            }
         break;
        default:
         break;
        }
      break;
      case CSYS_MIDI_PROGRAM:
       if ((CSYS_NULLPROGRAM == 0) && (ndata >= CSYS_MAXPRESETS))
         break;
       if ((cme_first[ec]))
        for (sysidx=*cme_first[ec];sysidx<=*cme_last[ec];sysidx++)
          if ((sysidx->numchan == ec + CSYS_EXTCHANSTART) &&
             (sysidx->noteon <= PLAYING))
           {
              sysidx->endtime = scorebeats - scoremult;
              sysidx->notenum += 256;
           }
       if ((CSYS_NULLPROGRAM == 0) || (ndata < CSYS_MAXPRESETS))
         {
          cme_first[ec] = cmp_first[ndata];
          cme_last[ec] = cmp_last[ndata];
          cme_end[ec] = cmp_end[ndata];
          cme_next[ec] = cmp_next[ndata];
         }
       else
         cme_first[ec] = cme_last[ec] = cme_end[ec] = cme_next[ec] = NULL;
      break;
      case CSYS_MIDI_SPECIAL:
       if (cmd == CSYS_MIDI_NEWTEMPO)
        {
         if (fval <= 0.0F)
           break;
         kbase = kcycleidx;
         scorebase = scorebeats;
         tempo = fval;
         scoremult = 1.666667e-02F*KTIME*tempo;
         endkcycle = kbase + (int)(KRATE*(endtime-scorebase)*
                     (60.0F/tempo));
         break;
        }
       if (cmd == CSYS_MIDI_ENDTIME)
        {
         if (fval <= scorebeats)
         {
           endtime = scorebeats;
           endkcycle = kcycleidx;
         }
         else
         {
           endtime = fval;
           endkcycle = kbase + (int)(KRATE*(endtime-scorebase)*
                       (60.0F/tempo));
         }
         break;
        }
       if (cmd == CSYS_MIDI_POWERUP)
        {
         ec &= 0xFFF0;
         memset(&(NG(CSYS_FRAMELEN*(ec+CSYS_EXTCHANSTART))), 0,
                sizeof(float)*CSYS_FRAMELEN*16);
         for (i = 0; i < 16; i++)
         {
           NG(CSYS_FRAMELEN*(ec + CSYS_EXTCHANSTART)+
              CSYS_MIDI_CC_CHANVOLUME_MSB) = 100.0F;
           NG(CSYS_FRAMELEN*(ec + CSYS_EXTCHANSTART)+
              CSYS_MIDI_CC_PAN_MSB) = 64.0F;
           NG(CSYS_FRAMELEN*(ec + CSYS_EXTCHANSTART)+
              CSYS_MIDI_CC_EXPRESSION_MSB) = 127.0F;
           NG(CSYS_FRAMELEN*(ec + CSYS_EXTCHANSTART)+
              CSYS_BENDPOS) = 8192.0F;
           NG(CSYS_FRAMELEN*(ec + CSYS_EXTCHANSTART)+
              CSYS_EXTPOS) = (float)ec;
           if ((cme_first[ec]))
            for (sysidx=*cme_first[ec];sysidx<=*cme_last[ec];sysidx++)
             if (sysidx->numchan == (ec + CSYS_EXTCHANSTART))
               {
                  sysidx->endtime =  scorebeats - scoremult;
                  sysidx->notenum += 256;
               }
           cme_first[ec] = cmp_first[i % CSYS_MAXPRESETS];
           cme_last[ec] = cmp_last[i % CSYS_MAXPRESETS];
           cme_end[ec] = cmp_end[i % CSYS_MAXPRESETS];
           cme_next[ec] = cmp_next[i % CSYS_MAXPRESETS];
           ec++;
         }
         break;
        }
      break;
      default:
      break;
     }
    } while (ne != CSYS_DONE);

 for (sysidx=cm_linbuzz___first;sysidx<=cm_linbuzz___last;sysidx++)
  {
  switch(sysidx->noteon) {
   case PLAYING:
   if (sysidx->released)
    {
     if (sysidx->turnoff)
      {
        sysidx->noteon = ALLDONE;
        for (i = 0; i < linbuzz_ENDTBL; i++)
         if (sysidx->nstate->t[i].llmem)
           free(sysidx->nstate->t[i].t);
        sysidx->nstate->iline = NULL;
      }
     else
      {
        sysidx->abstime -= KTIME;
        if (sysidx->abstime < 0.0F)
         {
           sysidx->noteon = ALLDONE;
           for (i = 0; i < linbuzz_ENDTBL; i++)
            if (sysidx->nstate->t[i].llmem)
             free(sysidx->nstate->t[i].t);
           sysidx->nstate->iline = NULL;
         }
        else
         sysidx->turnoff = sysidx->released = 0;
      }
    }
   else
    {
     if (sysidx->turnoff)
      {
       sysidx->released = 1;
      }
     else
      {
        if ((sysidx->endtime <= scorebeats) &&
        (NG(259*sysidx->nstate->iline->numchan+64) == 0.0F))
         {
           if (sysidx->abstime <= 0.0F)
             sysidx->turnoff = sysidx->released = 1;
           else
           {
             sysidx->abstime -= KTIME;
             if (sysidx->abstime < 0.0F)
               sysidx->turnoff = sysidx->released = 1;
           }
         }
        else
          if ((sysidx->abstime < 0.0F) &&
           (1.666667e-2F*tempo*sysidx->abstime + 
               sysidx->endtime <= scorebeats))
            sysidx->turnoff = sysidx->released = 1;
      }
    }
   break;
   case TOBEPLAYED:
    if (sysidx->starttime <= scorebeats)
     {
      sysidx->noteon = PLAYING;
      sysidx->notestate = nextstate;
      sysidx->nstate = &ninstr[nextstate];
      if (sysidx->sdur >= 0.0F)
        sysidx->endtime = scorebeats + sysidx->sdur;
      sysidx->kbirth = kcycleidx;
      ninstr[nextstate].iline = sysidx;
      sysidx->time = (kcycleidx-1)*KTIME;
       oldstate = nextstate;
       nextstate = (nextstate+1) % MAXSTATE;
       while ((oldstate != nextstate) && 
              (ninstr[nextstate].iline != NULL))
         nextstate = (nextstate+1) % MAXSTATE;
       if (oldstate == nextstate)
       {
         nextstate = (nextstate+1) % MAXSTATE;
         while ((oldstate != nextstate) && 
             (ninstr[nextstate].iline->time == 0.0F) &&
             (ninstr[nextstate].iline->noteon == PLAYING))
           nextstate = (nextstate+1) % MAXSTATE;
         ninstr[nextstate].iline->noteon = ALLDONE;
         ninstr[nextstate].iline = NULL;
       }
      linbuzz_ipass(sysidx->nstate);
    }
   break;
   default:
   break;
   }
 }
  while (cm_linbuzz___last->noteon == ALLDONE)
   if (cm_linbuzz___last == cm_linbuzz___first)
    {
     cm_linbuzz___first = &cm_linbuzz[1];
     cm_linbuzz___last =  &cm_linbuzz[0];
     cm_linbuzz___next =  NULL;
     cm_linbuzz___last->noteon = TOBEPLAYED;
     break;
    }
   else
    cm_linbuzz___last--;

}

void main_initpass(void)

{

  e_mix[0].noteon = PLAYING;
  e_mix[0].notestate = nextstate;
  e_mix[0].endtime = MAXENDTIME;
  e_mix[0].nstate = &ninstr[nextstate];
  ninstr[nextstate].iline = &e_mix[0];
       oldstate = nextstate;
       nextstate = (nextstate+1) % MAXSTATE;
       while ((oldstate != nextstate) && 
              (ninstr[nextstate].iline != NULL))
         nextstate = (nextstate+1) % MAXSTATE;
       if (oldstate == nextstate)
       {
         nextstate = (nextstate+1) % MAXSTATE;
         while ((oldstate != nextstate) && 
             (ninstr[nextstate].iline->time == 0.0F) &&
             (ninstr[nextstate].iline->noteon == PLAYING))
           nextstate = (nextstate+1) % MAXSTATE;
         ninstr[nextstate].iline->noteon = ALLDONE;
         ninstr[nextstate].iline = NULL;
       }
   mix1_ipass();


   if (csys_setup() != CSYS_DONE)
   epr(0,NULL,NULL,"control input device unavailable");

   if (asys_osetup((int)ARATE, ASYS_OCHAN, ASYS_OTYPENAME,  "linux",
ASYS_TIMEOPTION) != ASYS_DONE)
   epr(0,NULL,NULL,"audio output device unavailable");
   endkcycle = kbase + (int) 
      (KRATE*(endtime - scorebase)*(60.0F/tempo));

   if (asys_preamble(&asys_obuf, &asys_osize) != ASYS_DONE)
   epr(0,NULL,NULL,"audio output device unavailable");
   ksyncinit();


}

void main_control(void)

{

}


/*
#    Sfront, a SAOL to C translator    
#    This file: Robust file I/O, termination function
#    Copyright (C) 1999  Regents of the University of California
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License (Version 2) as
#    published by the Free Software Foundation.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#    Primary Author: John Lazzaro, lazzaro@cs.berkeley.edu
*/

/* handles termination in case of error */

void epr(int linenum, char * filename, char * token, char * message)

{

  fprintf(stderr, "\nRuntime Error.\n");
  if (filename != NULL)
    fprintf(stderr, "Location: File %s near line %i.\n",filename, linenum);
  if (token != NULL)
    fprintf(stderr, "While executing: %s.\n",token);
  if (message != NULL)
    fprintf(stderr, "Potential problem: %s.\n",message);
  fprintf(stderr, "Exiting program.\n\n");
  exit(-1);

}

/* robust replacement for fread() */

size_t rread(void * ptr, size_t size, size_t nmemb, FILE * stream)

{
  long recv;
  long len;
  long retry;
  char * c;

  /* fast path */

  if ((recv = fread(ptr, size, nmemb, stream)) == nmemb)
    return nmemb;

  /* error recovery */
     
  c = (char *) ptr;
  len = retry = 0;

  do 
    {
      if (++retry > IOERROR_RETRY)
	{
	  len = recv = 0;
	  break;
	}

      if (feof(stream))
	{
	  clearerr(stream);
	  break;
	}

      /* ANSI, not POSIX, so can't look for EINTR/EAGAIN  */
      /* Assume it was one of these and retry.            */

      clearerr(stream);
      len += recv;
      nmemb -= recv;

    }
  while ((recv = fread(&(c[len]), size, nmemb, stream)) != nmemb);

  return (len += recv);

}

/* robust replacement for fwrite() */

size_t rwrite(void * ptr, size_t size, size_t nmemb, FILE * stream)

{
  long recv;
  long len;
  long retry;
  char * c;

  /* fast path */

  if ((recv = fwrite(ptr, size, nmemb, stream)) == nmemb)
    return nmemb;

  /* error recovery */
     
  c = (char *) ptr;
  len = retry = 0;

  do 
    {
      if (++retry > IOERROR_RETRY)
	{
	  len = recv = 0;
	  break;
	}

      /* ANSI, not POSIX, so can't look for EINTR/EAGAIN  */
      /* Assume it was one of these and retry.            */

      len += recv;
      nmemb -= recv;

    }
  while ((recv = fwrite(&(c[len]), size, nmemb, stream)) != nmemb);

  return (len += recv);

}



/*
#    Sfront, a SAOL to C translator    
#    This file: Main loop for runtime
#    Copyright (C) 1999  Regents of the University of California
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License (Version 2) as
#    published by the Free Software Foundation.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#    Primary Author: John Lazzaro, lazzaro@cs.berkeley.edu
*/

int main(int argc, char *argv[])

{
  system_init(argc, argv);
  effects_init();
  main_initpass();
  for (kcycleidx=kbase; kcycleidx<=endkcycle; kcycleidx++)
    {
      pass = IPASS;
      scorebeats = scoremult*(kcycleidx - kbase) + scorebase;
      absolutetime = (kcycleidx - 1)*KTIME;
      main_ipass();
      pass = KPASS;
      main_control();
      if (main_kpass())
	break;
      pass = APASS;
      for (acycleidx=0; acycleidx<ACYCLE; acycleidx++)
	{
	  for (busidx=0; busidx<ENDBUS;busidx++)
	    bus[busidx]=0.0F;
	  main_apass();
	  for (busidx=BUS_output_bus; busidx<ENDBUS_output_bus;busidx++)
	    {
	      bus[busidx] = (bus[busidx] >  1.0F) ?  1.0F : bus[busidx];
	      bus[busidx] = (bus[busidx] < -1.0F) ? -1.0F : bus[busidx];
	      asys_obuf[obusidx++] = (short) (32767.0F * bus[busidx]);
	    }
	  if (obusidx >= asys_osize)
	    {
	      obusidx = 0;
	      if (asys_putbuf(&asys_obuf, &asys_osize))
		{
		  fprintf(stderr,"  Sfront: Audio output device problem\n\n");
		  kcycleidx = endkcycle;
		  break;
		}
	    }
	}
      acycleidx = 0; 
      cpuload = ksync();
    }
  shut_down();
  return 0;
}





